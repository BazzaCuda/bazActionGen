{   bazLib / bazAction
    Copyright (C) 2021-2099 Baz Cuda
    https://github.com/BazzaCuda/

    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307, USA
}
unit bazAction;

interface

{ THIS UNIT IS GENERATED BY bazActionGen.exe. AMEND THE bazActionDefs.txt FILE TO REGENERATE THIS UNIT FOR DIFFERENT FUNCTION TYPES AND FUNCTION SIGNATURES }

type
  TVoid = record end;

  // NoParam types
  TOFuncNoParam<TResult> = function(): TResult of object;
  TSFuncNoParam<TResult> = function(): TResult;
  TAFuncNoParam<TResult> = reference to function(): TResult;

  // Generic Parameter types
  TOFunc<T, TResult> = function(const  aParam: T): TResult of object;
  TSFunc<T, TResult> = function(const  aParam: T): TResult;
  TAFunc<T, TResult> = reference to function(const  aParam: T): TResult;

  // Dual Generic Parameter types
  TOFuncDual<T1, T2, TResult> = function(const  aParam1: T1; const  aParam2: T2): TResult of object;
  TSFuncDual<T1, T2, TResult> = function(const  aParam1: T1; const  aParam2: T2): TResult;
  TAFuncDual<T1, T2, TResult> = reference to function(const  aParam1: T1; const  aParam2: T2): TResult;

  IAction<TResult> = interface
    function  perform(): TResult;
    function  getAssigned: boolean;
    property  assigned: boolean read getAssigned;
  end;

  IActionGeneric<T, TResult> = interface(IAction<TResult>)
    function  perform(const  aParam: T): TResult;
  end;

  IActionGenericDual<T1, T2, TResult> = interface(IAction<TResult>)
    function  perform(const  aParam1: T1; const  aParam2: T2): TResult;
  end;

  TAction<TResult> = class(TInterfacedObject, IAction<TResult>)
  protected
    FFuncAssigned: boolean;
    FOFuncNoParam: TOFuncNoParam<TResult>;
    FSFuncNoParam: TSFuncNoParam<TResult>;
    FAFuncNoParam: TAFuncNoParam<TResult>;
  public
    constructor Create(const  aFuncNIL: pointer); overload;
    constructor Create(const  aFunc: TOFuncNoParam<TResult>); overload;
    constructor Create(const  aFunc: TSFuncNoParam<TResult>); overload;
    constructor Create(const  aFunc: TAFuncNoParam<TResult>); overload;

    class function  pick(const  bBoolean: boolean; const  aTrueFunc: TOFuncNoParam<TResult>): IAction<TResult>; overload;
    class function  pick(const  bBoolean: boolean; const  aTrueFunc: TSFuncNoParam<TResult>): IAction<TResult>; overload;
    class function  pick(const  bBoolean: boolean; const  aTrueFunc: TAFuncNoParam<TResult>): IAction<TResult>; overload;

    function  getAssigned: boolean;
    function  perform(): TResult; virtual;
  end;

  TActionGeneric<T, TResult> = class(TAction<TResult>, IActionGeneric<T, TResult>)
  strict private
    FOFunc: TOFunc<T, TResult>;
    FSFunc: TSFunc<T, TResult>;
    FAFunc: TAFunc<T, TResult>;
  public
    constructor Create(const  aFunc: TOFunc<T, TResult>); overload;
    constructor Create(const  aFunc: TSFunc<T, TResult>); overload;
    constructor Create(const  aFunc: TAFunc<T, TResult>); overload;

    class function  pick(const  bBoolean: boolean; const  aTrueFunc: TOFunc<T, TResult>): IActionGeneric<T, TResult>; overload;
    class function  pick(const  bBoolean: boolean; const  aTrueFunc: TSFunc<T, TResult>): IActionGeneric<T, TResult>; overload;
    class function  pick(const  bBoolean: boolean; const  aTrueFunc: TAFunc<T, TResult>): IActionGeneric<T, TResult>; overload;

    function  perform(const  aParam: T): TResult;
  end;

  TActionGenericDual<T1, T2, TResult> = class(TAction<TResult>, IActionGenericDual<T1, T2, TResult>)
  strict private
    FOFunc: TOFuncDual<T1, T2, TResult>;
    FSFunc: TSFuncDual<T1, T2, TResult>;
    FAFunc: TAFuncDual<T1, T2, TResult>;
  public
    constructor Create(const  aFunc: TOFuncDual<T1, T2, TResult>); overload;
    constructor Create(const  aFunc: TSFuncDual<T1, T2, TResult>); overload;
    constructor Create(const  aFunc: TAFuncDual<T1, T2, TResult>); overload;

    class function  pick(const  bBoolean: boolean; const  aTrueFunc: TOFuncDual<T1, T2, TResult>): IActionGenericDual<T1, T2, TResult>; overload;
    class function  pick(const  bBoolean: boolean; const  aTrueFunc: TSFuncDual<T1, T2, TResult>): IActionGenericDual<T1, T2, TResult>; overload;
    class function  pick(const  bBoolean: boolean; const  aTrueFunc: TAFuncDual<T1, T2, TResult>): IActionGenericDual<T1, T2, TResult>; overload;

    function  perform(const  aParam1: T1; const  aParam2: T2): TResult;
  end;

implementation

uses
  bazRTL;

{ TAction<TResult> }

constructor TAction<TResult>.Create(const  aFuncNIL: pointer);
begin
  case aFuncNIL = NIL of
     TRUE: EXIT;
    FALSE: raise  exception.create('NIL constructor requires NIL'); end;
end;

constructor TAction<TResult>.Create(const  aFunc: TOFuncNoParam<TResult>);
begin
  FOFuncNoParam := aFunc;
  FFuncAssigned := assigned(aFunc);
end;

constructor TAction<TResult>.Create(const  aFunc: TSFuncNoParam<TResult>);
begin
  FSFuncNoParam := aFunc;
  FFuncAssigned := assigned(aFunc);
end;

constructor TAction<TResult>.Create(const  aFunc: TAFuncNoParam<TResult>);
begin
  FAFuncNoParam := aFunc;
  FFuncAssigned := assigned(aFunc);
end;

class function  TAction<TResult>.pick(const  bBoolean: boolean; const  aTrueFunc: TOFuncNoParam<TResult>): IAction<TResult>;
begin
  case bBoolean of
     TRUE: result := TAction<TResult>.Create(aTrueFunc);
    FALSE: result := TAction<TResult>.Create(NIL); end;
end;

class function  TAction<TResult>.pick(const  bBoolean: boolean; const  aTrueFunc: TSFuncNoParam<TResult>): IAction<TResult>;
begin
  case bBoolean of
     TRUE: result := TAction<TResult>.Create(aTrueFunc);
    FALSE: result := TAction<TResult>.Create(NIL); end;
end;

class function  TAction<TResult>.pick(const  bBoolean: boolean; const  aTrueFunc: TAFuncNoParam<TResult>): IAction<TResult>;
begin
  case bBoolean of
     TRUE: result := TAction<TResult>.Create(aTrueFunc);
    FALSE: result := TAction<TResult>.Create(NIL); end;
end;

function  TAction<TResult>.getAssigned: boolean;
begin
  result := FFuncAssigned;
end;

function  TAction<TResult>.perform: TResult;
begin
  result := default(TResult);
  case assigned(FOFuncNoParam) of TRUE: EXIT(FOFuncNoParam()); end;
  case assigned(FSFuncNoParam) of TRUE: EXIT(FSFuncNoParam()); end;
  case assigned(FAFuncNoParam) of TRUE: EXIT(FAFuncNoParam()); end;
end;

{ TActionGeneric<T, TResult> }

constructor TActionGeneric<T, TResult>.Create(const  aFunc: TOFunc<T, TResult>);
begin
  FOFunc := aFunc;
  FFuncAssigned := assigned(aFunc);
end;

constructor TActionGeneric<T, TResult>.Create(const  aFunc: TSFunc<T, TResult>);
begin
  FSFunc := aFunc;
  FFuncAssigned := assigned(aFunc);
end;

constructor TActionGeneric<T, TResult>.Create(const  aFunc: TAFunc<T, TResult>);
begin
  FAFunc := aFunc;
  FFuncAssigned := assigned(aFunc);
end;

class function  TActionGeneric<T, TResult>.pick(const  bBoolean: boolean; const  aTrueFunc: TOFunc<T, TResult>): IActionGeneric<T, TResult>;
begin
  case bBoolean of
     TRUE: result := TActionGeneric<T, TResult>.Create(aTrueFunc);
    FALSE: result := TActionGeneric<T, TResult>.Create(NIL); end;
end;

class function  TActionGeneric<T, TResult>.pick(const  bBoolean: boolean; const  aTrueFunc: TSFunc<T, TResult>): IActionGeneric<T, TResult>;
begin
  case bBoolean of
     TRUE: result := TActionGeneric<T, TResult>.Create(aTrueFunc);
    FALSE: result := TActionGeneric<T, TResult>.Create(NIL); end;
end;

class function  TActionGeneric<T, TResult>.pick(const  bBoolean: boolean; const  aTrueFunc: TAFunc<T, TResult>): IActionGeneric<T, TResult>;
begin
  case bBoolean of
     TRUE: result := TActionGeneric<T, TResult>.Create(aTrueFunc);
    FALSE: result := TActionGeneric<T, TResult>.Create(NIL); end;
end;

function  TActionGeneric<T, TResult>.perform(const  aParam: T): TResult;
begin
  result := default(TResult);
  case assigned(FOFunc) of TRUE: EXIT(FOFunc(aParam)); end;
  case assigned(FSFunc) of TRUE: EXIT(FSFunc(aParam)); end;
  case assigned(FAFunc) of TRUE: EXIT(FAFunc(aParam)); end;
end;

{ TActionGenericDual<T1, T2, TResult> }

constructor TActionGenericDual<T1, T2, TResult>.Create(const  aFunc: TOFuncDual<T1, T2, TResult>);
begin
  FOFunc := aFunc;
  FFuncAssigned := assigned(aFunc);
end;

constructor TActionGenericDual<T1, T2, TResult>.Create(const  aFunc: TSFuncDual<T1, T2, TResult>);
begin
  FSFunc := aFunc;
  FFuncAssigned := assigned(aFunc);
end;

constructor TActionGenericDual<T1, T2, TResult>.Create(const  aFunc: TAFuncDual<T1, T2, TResult>);
begin
  FAFunc := aFunc;
  FFuncAssigned := assigned(aFunc);
end;

class function  TActionGenericDual<T1, T2, TResult>.pick(const  bBoolean: boolean; const  aTrueFunc: TOFuncDual<T1, T2, TResult>): IActionGenericDual<T1, T2, TResult>;
begin
  case bBoolean of
     TRUE: result := TActionGenericDual<T1, T2, TResult>.Create(aTrueFunc);
    FALSE: result := TActionGenericDual<T1, T2, TResult>.Create(NIL); end;
end;

class function  TActionGenericDual<T1, T2, TResult>.pick(const  bBoolean: boolean; const  aTrueFunc: TSFuncDual<T1, T2, TResult>): IActionGenericDual<T1, T2, TResult>;
begin
  case bBoolean of
     TRUE: result := TActionGenericDual<T1, T2, TResult>.Create(aTrueFunc);
    FALSE: result := TActionGenericDual<T1, T2, TResult>.Create(NIL); end;
end;

class function  TActionGenericDual<T1, T2, TResult>.pick(const  bBoolean: boolean; const  aTrueFunc: TAFuncDual<T1, T2, TResult>): IActionGenericDual<T1, T2, TResult>;
begin
  case bBoolean of
     TRUE: result := TActionGenericDual<T1, T2, TResult>.Create(aTrueFunc);
    FALSE: result := TActionGenericDual<T1, T2, TResult>.Create(NIL); end;
end;

function  TActionGenericDual<T1, T2, TResult>.perform(const  aParam1: T1; const  aParam2: T2): TResult;
begin
  result := default(TResult);
  case assigned(FOFunc) of TRUE: EXIT(FOFunc(aParam1, aParam2)); end;
  case assigned(FSFunc) of TRUE: EXIT(FSFunc(aParam1, aParam2)); end;
  case assigned(FAFunc) of TRUE: EXIT(FAFunc(aParam1, aParam2)); end;
end;

end.
