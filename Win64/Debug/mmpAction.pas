{   bazLib / bazAction
    Copyright (C) 2021-2099 Baz Cuda
    https://github.com/BazzaCuda/bazLib

    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307, USA
}
unit mmpAction;

interface

{ THIS UNIT IS GENERATED BY bazActionGen.exe. AMEND THE bazActionDefs.txt FILE TO REGENERATE THIS UNIT FOR DIFFERENT FUNCTION TYPES AND FUNCTION SIGNATURES }
{ These are project-specific datatypes added via identically-named descendants of bazAction.IAction and bazAction.TAction }

uses
  bazAction;

type
  TVoid = bazAction.TVoid;


  TOFuncBooleanString       <TResult> = function(const aBoolean: boolean; const aString: string):                       TResult of object; // method of class instance
  TSFuncBooleanString       <TResult> = function(const aBoolean: boolean; const aString: string):                       TResult;           // static method - no class instance
  TAFuncBooleanString       <TResult> = reference to function(const aBoolean: boolean; const aString: string):          TResult;           // anonymous method


  TOProcBooleanString        = procedure(const aBoolean: boolean; const aString: string)                        of object; // method of class instance
  TSProcBooleanString        = procedure(const aBoolean: boolean; const aString: string)                       ;           // static method - no class instance
  TAProcBooleanString        = reference to procedure(const aBoolean: boolean; const aString: string)          ;           // anonymous method

  IAction<TResult> = interface(bazAction.IAction<TResult>)
    function perform(const aBoolean: boolean; const aString: string): TResult; overload;

    function andThen(const aGuardClause: boolean; const aTrueFunc: TOFuncBooleanString<TResult>; const aBoolean: boolean; const aString: string): IAction<TResult>; overload;
    function andThen(const aGuardClause: boolean; const aTrueFunc: TSFuncBooleanString<TResult>; const aBoolean: boolean; const aString: string): IAction<TResult>; overload;
    function andThen(const aGuardClause: boolean; const aTrueFunc: TAFuncBooleanString<TResult>; const aBoolean: boolean; const aString: string): IAction<TResult>; overload;

    function plus(const aGuardClause: boolean; const aTrueFunc: TOFuncBooleanString<TResult>; const aBoolean: boolean; const aString: string): IAction<TResult>; overload;
    function plus(const aGuardClause: boolean; const aTrueFunc: TSFuncBooleanString<TResult>; const aBoolean: boolean; const aString: string): IAction<TResult>; overload;
    function plus(const aGuardClause: boolean; const aTrueFunc: TAFuncBooleanString<TResult>; const aBoolean: boolean; const aString: string): IAction<TResult>; overload;
  end;

  TAction<TResult> = class(bazAction.TAction<TResult>, mmpAction.IAction<TResult>)

    FOFuncBooleanString:                TOFuncBooleanString                  <TResult>;
    FSFuncBooleanString:                TAFuncBooleanString                  <TResult>;
    FAFuncBooleanString:                TAFuncBooleanString                  <TResult>;
    constructor Create;                           overload;
    constructor Create(const aFuncNIL: pointer);  overload;

    constructor Create(const aFuncBooleanString:     TOFuncBooleanString      <TResult>);     overload;
    constructor Create(const aFuncBooleanString:     TSFuncBooleanString      <TResult>);     overload;
    constructor Create(const aFuncBooleanString:     TAFuncBooleanString      <TResult>);     overload;


    class function pick(const aBoolean: boolean; const aTrueFunc: TOFuncBooleanString<TResult>): IAction<TResult>; overload;
    class function pick(const aBoolean: boolean; const aTrueFunc: TSFuncBooleanString<TResult>): IAction<TResult>; overload;
    class function pick(const aBoolean: boolean; const aTrueFunc: TAFuncBooleanString<TResult>): IAction<TResult>; overload;

    class function pick(const aBoolean: boolean; const aTrueFunc: TOFuncBooleanString<TResult>; const aFalseFunc: TOFuncBooleanString<TResult>): IAction<TResult>; overload;
    class function pick(const aBoolean: boolean; const aTrueFunc: TSFuncBooleanString<TResult>; const aFalseFunc: TSFuncBooleanString<TResult>): IAction<TResult>; overload;
    class function pick(const aBoolean: boolean; const aTrueFunc: TAFuncBooleanString<TResult>; const aFalseFunc: TAFuncBooleanString<TResult>): IAction<TResult>; overload;

    function perform(const aBoolean: boolean; const aString: string): TResult; overload;


    function andThen(const aGuardClause: boolean; const aTrueFunc: TOFuncBooleanString<TResult>; const aBoolean: boolean; const aString: string): IAction<TResult>; overload;
    function andThen(const aGuardClause: boolean; const aTrueFunc: TSFuncBooleanString<TResult>; const aBoolean: boolean; const aString: string): IAction<TResult>; overload;
    function andThen(const aGuardClause: boolean; const aTrueFunc: TAFuncBooleanString<TResult>; const aBoolean: boolean; const aString: string): IAction<TResult>; overload;

    function plus(const aGuardClause: boolean; const aTrueFunc: TOFuncBooleanString<TResult>; const aBoolean: boolean; const aString: string): IAction<TResult>; overload;
    function plus(const aGuardClause: boolean; const aTrueFunc: TSFuncBooleanString<TResult>; const aBoolean: boolean; const aString: string): IAction<TResult>; overload;
    function plus(const aGuardClause: boolean; const aTrueFunc: TAFuncBooleanString<TResult>; const aBoolean: boolean; const aString: string): IAction<TResult>; overload;
  end;

  IAction = interface(bazAction.IAction)
    procedure perform(const aBoolean: boolean; const aString: string); overload;
  end;

  TAction = class(bazAction.TAction, mmpAction.IAction)

    FOProcBooleanString:                TOProcBooleanString                  ;
    FSProcBooleanString:                TAProcBooleanString                  ;
    FAProcBooleanString:                TAProcBooleanString                  ;
    constructor Create;                           overload;
    constructor Create(const aProcNIL: pointer);  overload;

    constructor Create(const aProcBooleanString:     TOProcBooleanString       );     overload;
    constructor Create(const aProcBooleanString:     TSProcBooleanString       );     overload;
    constructor Create(const aProcBooleanString:     TAProcBooleanString       );     overload;


    class function pick(const aBoolean: boolean; const aTrueProc: TOProcBooleanString): IAction; overload;
    class function pick(const aBoolean: boolean; const aTrueProc: TSProcBooleanString): IAction; overload;
    class function pick(const aBoolean: boolean; const aTrueProc: TAProcBooleanString): IAction; overload;

    class function pick(const aBoolean: boolean; const aTrueProc: TOProcBooleanString; const aFalseProc: TOProcBooleanString): IAction; overload;
    class function pick(const aBoolean: boolean; const aTrueProc: TSProcBooleanString; const aFalseProc: TSProcBooleanString): IAction; overload;
    class function pick(const aBoolean: boolean; const aTrueProc: TAProcBooleanString; const aFalseProc: TAProcBooleanString): IAction; overload;

    procedure perform(const aBoolean: boolean; const aString: string); overload;

  end;

implementation

uses
  bazRTL;

{ TAction<TResult> }

constructor TAction<TResult>.Create;
begin
  raise exception.create('Don''t call TAction.create');
end;

constructor TAction<TResult>.Create(const aFuncNIL: pointer);
begin
  case aFuncNIL = NIL of   TRUE: EXIT;
                          FALSE: raise exception.Create('Methodless constructor must be called with NIL'); end;
end;
constructor TAction<TResult>.Create(const aFuncBooleanString: TOFuncBooleanString<TResult>);
begin
  FOFuncBooleanString  := aFuncBooleanString;
  methodAssigned       := assigned(aFuncBooleanString);
end;

constructor TAction<TResult>.Create(const aFuncBooleanString: TSFuncBooleanString<TResult>);
begin
  FSFuncBooleanString  := aFuncBooleanString;
  methodAssigned       := assigned(aFuncBooleanString);
end;

constructor TAction<TResult>.Create(const aFuncBooleanString: TAFuncBooleanString<TResult>);
begin
  FAFuncBooleanString  := aFuncBooleanString;
  methodAssigned       := assigned(aFuncBooleanString);
end;

class function TAction<TResult>.pick(const aBoolean: boolean; const aTrueFunc: TOFuncBooleanString<TResult>): IAction<TResult>;
begin
  case aBoolean of
     TRUE:  result := IAction<TResult>(pointer(TAction<TResult>.Create(aTrueFunc)));
    FALSE:  result := IAction<TResult>(pointer(TAction<TResult>.Create(NIL)));
  end;
end;

class function TAction<TResult>.pick(const aBoolean: boolean; const aTrueFunc: TSFuncBooleanString<TResult>): IAction<TResult>;
begin
  case aBoolean of
     TRUE:  result := IAction<TResult>(pointer(TAction<TResult>.Create(aTrueFunc)));
    FALSE:  result := IAction<TResult>(pointer(TAction<TResult>.Create(NIL)));
  end;
end;

class function TAction<TResult>.pick(const aBoolean: boolean; const aTrueFunc: TAFuncBooleanString<TResult>): IAction<TResult>;
begin
  case aBoolean of
     TRUE:  result := IAction<TResult>(pointer(TAction<TResult>.Create(aTrueFunc)));
    FALSE:  result := IAction<TResult>(pointer(TAction<TResult>.Create(NIL)));
  end;
end;

class function TAction<TResult>.pick(const aBoolean: boolean; const aTrueFunc: TOFuncBooleanString<TResult>; const aFalseFunc: TOFuncBooleanString<TResult>): IAction<TResult>;
begin
  case aBoolean of
     TRUE:  result := IAction<TResult>(pointer(TAction<TResult>.Create(aTrueFunc)));
    FALSE:  result := IAction<TResult>(pointer(TAction<TResult>.Create(aFalseFunc)));
  end;
end;

class function TAction<TResult>.pick(const aBoolean: boolean; const aTrueFunc: TSFuncBooleanString<TResult>; const aFalseFunc: TSFuncBooleanString<TResult>): IAction<TResult>;
begin
  case aBoolean of
     TRUE:  result := IAction<TResult>(pointer(TAction<TResult>.Create(aTrueFunc)));
    FALSE:  result := IAction<TResult>(pointer(TAction<TResult>.Create(aFalseFunc)));
  end;
end;

class function TAction<TResult>.pick(const aBoolean: boolean; const aTrueFunc: TAFuncBooleanString<TResult>; const aFalseFunc: TAFuncBooleanString<TResult>): IAction<TResult>;
begin
  case aBoolean of
     TRUE:  result := IAction<TResult>(pointer(TAction<TResult>.Create(aTrueFunc)));
    FALSE:  result := IAction<TResult>(pointer(TAction<TResult>.Create(aFalseFunc)));
  end;
end;

function TAction<TResult>.perform(const aBoolean: boolean; const aString: string): TResult;
begin
  result := getDefault;
  case assigned(FOFuncBooleanString) of TRUE: EXIT(FOFuncBooleanString(aBoolean, aString)); end;
  case assigned(FSFuncBooleanString) of TRUE: EXIT(FSFuncBooleanString(aBoolean, aString)); end;
  case assigned(FAFuncBooleanString) of TRUE: EXIT(FAFuncBooleanString(aBoolean, aString)); end;
end;


function TAction<TResult>.andThen(const aGuardClause: boolean; const aTrueFunc: TOFuncBooleanString<TResult>; const aBoolean: boolean; const aString: string): IAction<TResult>;
var
  vResult: TResult;
  bResult: boolean absolute vResult;
begin
  case success and aGuardClause of TRUE: begin
                                            vResult := aTrueFunc(aBoolean, aString);
                                            success := bResult; end;end;
  result := SELF;
end;

function TAction<TResult>.andThen(const aGuardClause: boolean; const aTrueFunc: TSFuncBooleanString<TResult>; const aBoolean: boolean; const aString: string): IAction<TResult>;
var
  vResult: TResult;
  bResult: boolean absolute vResult;
begin
  case success and aGuardClause of TRUE: begin
                                            vResult := aTrueFunc(aBoolean, aString);
                                            success := bResult; end;end;
  result := SELF;
end;

function TAction<TResult>.andThen(const aGuardClause: boolean; const aTrueFunc: TAFuncBooleanString<TResult>; const aBoolean: boolean; const aString: string): IAction<TResult>;
var
  vResult: TResult;
  bResult: boolean absolute vResult;
begin
  case success and aGuardClause of TRUE: begin
                                            vResult := aTrueFunc(aBoolean, aString);
                                            success := bResult; end;end;
  result := SELF;
end;

function TAction<TResult>.plus(const aGuardClause: boolean; const aTrueFunc: TOFuncBooleanString<TResult>; const aBoolean: boolean; const aString: string): IAction<TResult>;
begin
  case success and aGuardClause of TRUE: aTrueFunc(aBoolean, aString); end;
  result := SELF;
end;

function TAction<TResult>.plus(const aGuardClause: boolean; const aTrueFunc: TSFuncBooleanString<TResult>; const aBoolean: boolean; const aString: string): IAction<TResult>;
begin
  case success and aGuardClause of TRUE: aTrueFunc(aBoolean, aString); end;
  result := SELF;
end;

function TAction<TResult>.plus(const aGuardClause: boolean; const aTrueFunc: TAFuncBooleanString<TResult>; const aBoolean: boolean; const aString: string): IAction<TResult>;
begin
  case success and aGuardClause of TRUE: aTrueFunc(aBoolean, aString); end;
  result := SELF;
end;

{ TAction }

constructor TAction.Create;
begin
  raise exception.create('Don''t call TAction.create');
end;

constructor TAction.Create(const aProcNIL: pointer);
begin
  case aProcNIL = NIL of   TRUE: EXIT;
                          FALSE: raise exception.Create('Methodless constructor must be called with NIL'); end;
end;
constructor TAction.Create(const aProcBooleanString: TOProcBooleanString);
begin
  FOProcBooleanString  := aProcBooleanString;
  methodAssigned       := assigned(aProcBooleanString);
end;

constructor TAction.Create(const aProcBooleanString: TSProcBooleanString);
begin
  FSProcBooleanString  := aProcBooleanString;
  methodAssigned       := assigned(aProcBooleanString);
end;

constructor TAction.Create(const aProcBooleanString: TAProcBooleanString);
begin
  FAProcBooleanString  := aProcBooleanString;
  methodAssigned       := assigned(aProcBooleanString);
end;

class function TAction.pick(const aBoolean: boolean; const aTrueProc: TOProcBooleanString): IAction;
begin
  case aBoolean of
     TRUE:  result := IAction(pointer(TAction.Create(aTrueProc)));
    FALSE:  result := IAction(pointer(TAction.Create(NIL)));
  end;
end;

class function TAction.pick(const aBoolean: boolean; const aTrueProc: TSProcBooleanString): IAction;
begin
  case aBoolean of
     TRUE:  result := IAction(pointer(TAction.Create(aTrueProc)));
    FALSE:  result := IAction(pointer(TAction.Create(NIL)));
  end;
end;

class function TAction.pick(const aBoolean: boolean; const aTrueProc: TAProcBooleanString): IAction;
begin
  case aBoolean of
     TRUE:  result := IAction(pointer(TAction.Create(aTrueProc)));
    FALSE:  result := IAction(pointer(TAction.Create(NIL)));
  end;
end;

class function TAction.pick(const aBoolean: boolean; const aTrueProc: TOProcBooleanString; const aFalseProc: TOProcBooleanString): IAction;
begin
  case aBoolean of
     TRUE:  result := IAction(pointer(TAction.Create(aTrueProc)));
    FALSE:  result := IAction(pointer(TAction.Create(aFalseProc)));
  end;
end;

class function TAction.pick(const aBoolean: boolean; const aTrueProc: TSProcBooleanString; const aFalseProc: TSProcBooleanString): IAction;
begin
  case aBoolean of
     TRUE:  result := IAction(pointer(TAction.Create(aTrueProc)));
    FALSE:  result := IAction(pointer(TAction.Create(aFalseProc)));
  end;
end;

class function TAction.pick(const aBoolean: boolean; const aTrueProc: TAProcBooleanString; const aFalseProc: TAProcBooleanString): IAction;
begin
  case aBoolean of
     TRUE:  result := IAction(pointer(TAction.Create(aTrueProc)));
    FALSE:  result := IAction(pointer(TAction.Create(aFalseProc)));
  end;
end;

procedure TAction.perform(const aBoolean: boolean; const aString: string);
begin
  case assigned(FOProcBooleanString) of TRUE: FOProcBooleanString(aBoolean, aString); end;
  case assigned(FSProcBooleanString) of TRUE: FSProcBooleanString(aBoolean, aString); end;
  case assigned(FAProcBooleanString) of TRUE: FAProcBooleanString(aBoolean, aString); end;
end;

end.
