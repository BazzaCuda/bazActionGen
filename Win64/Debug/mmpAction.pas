{   bazLib / bazAction
    Copyright (C) 2021-2099 Baz Cuda
    https://github.com/BazzaCuda/bazLib

    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307, USA
}
unit mmpAction;

interface

{ THIS UNIT IS GENERATED BY bazActionGen.exe. AMEND THE bazActionDefs.txt FILE TO REGENERATE THIS UNIT FOR DIFFERENT FUNCTION TYPES AND FUNCTION SIGNATURES }
{ These are project-specific datatypes added via identically-named descendants of bazAction.TAction }

uses
  bazAction, bazFuncDefs;
      
type

  TAction<TResult> = class(bazAction.TAction<TResult>)

    FAFuncBooleanString:                TAFuncBooleanString                  <TResult>;

    constructor Create;                           overload;
    constructor Create(const aFuncNIL: pointer);  overload;
    constructor Create(const aFuncBooleanString:     TAFuncBooleanString      <TResult>);     overload;

    class function pick(const aBoolean: boolean; const aTrueFunc: TAFuncBooleanString                                                   <TResult>): TAction<TResult>; overload;

    class function pick(const aBoolean: boolean; const aTrueFunc: TAFuncBooleanString<TResult>; const aFalseFunc: TAFuncBooleanString   <TResult>): TAction<TResult>; overload;

    function  perform(const aBoolean: boolean; const aString: string): TResult; overload;


    function  andThen(const aGuardClause: boolean; const aTrueFunc: TAFuncBooleanString<boolean>; const aBoolean: boolean; const aString: string): TAction<TResult>; overload;

    function  aside(const aGuardClause: boolean; const aTrueFunc: TAFuncBooleanString<boolean>; const aBoolean: boolean; const aString: string): TAction<TResult>; overload;

    function  aside<T>(const aGuardClause: boolean; const aTrueFunc: TAFuncBooleanString<T>; const aBoolean: boolean; const aString: string): TAction<TResult>; overload;
  end;

  TAction = class(bazAction.TAction)

    FAProcBooleanString:                TAProcBooleanString                  ;

    constructor Create;                           overload;
    constructor Create(const aProcNIL: pointer);  overload;
    constructor Create(const aProcBooleanString:     TAProcBooleanString       );     overload;


    class function pick(const aBoolean: boolean; const aTrueProc: TAProcBooleanString                                                   ): TAction; overload;
    class function pick(const aBoolean: boolean; const aTrueProc: TAProcBooleanString; const aFalseProc: TAProcBooleanString            ): TAction; overload;

    procedure  perform(const aBoolean: boolean; const aString: string); overload;




  end;

implementation

uses
  bazRTL;

{ TAction<TResult> }

constructor TAction<TResult>.Create;
begin
  raise exception.create('Don''t call TAction.create');
end;

constructor TAction<TResult>.Create(const aFuncNIL: pointer);
begin
  case aFuncNIL = NIL of   TRUE: EXIT;
                          FALSE: raise exception.Create('Methodless constructor must be called with NIL'); end;
end;
constructor TAction<TResult>.Create(const aFuncBooleanString: TAFuncBooleanString<TResult>);
begin
  FAFuncBooleanString  := aFuncBooleanString;
  methodAssigned       := assigned(aFuncBooleanString);
end;

class function TAction<TResult>.pick(const aBoolean: boolean; const aTrueFunc: TAFuncBooleanString<TResult>): TAction<TResult>;
begin
  case aBoolean of
     TRUE:  result := TAction<TResult>.Create(aTrueFunc);
    FALSE:  result := TAction<TResult>.Create(NIL);
  end;
end;

class function TAction<TResult>.pick(const aBoolean: boolean; const aTrueFunc: TAFuncBooleanString<TResult>; const aFalseFunc: TAFuncBooleanString<TResult>): TAction<TResult>;
begin
  case aBoolean of
     TRUE:  result := TAction<TResult>.Create(aTrueFunc);
    FALSE:  result := TAction<TResult>.Create(aFalseFunc);
  end;
end;


function TAction<TResult>.perform(const aBoolean: boolean; const aString: string): TResult;
begin
  result := getDefault;
  try
    case assigned(FAFuncBooleanString) of TRUE: EXIT(FAFuncBooleanString(aBoolean, aString)); end;
  finally
    SELF.free;
  end;
end;

function TAction<TResult>.andThen(const aGuardClause: boolean; const aTrueFunc: TAFuncBooleanString<boolean>; const aBoolean: boolean; const aString: string): TAction<TResult>;
begin
  case success and aGuardClause of TRUE: success := aTrueFunc(aBoolean, aString); end;
  result := SELF;
end;

function TAction<TResult>.aside(const aGuardClause: boolean; const aTrueFunc: TAFuncBooleanString<boolean>; const aBoolean: boolean; const aString: string): TAction<TResult>;
begin
  case success and aGuardClause of TRUE: aTrueFunc(aBoolean, aString); end;
  result := SELF;
end;

function TAction<TResult>.aside<T>(const aGuardClause: boolean; const aTrueFunc: TAFuncBooleanString<T>; const aBoolean: boolean; const aString: string): TAction<TResult>;
begin
  case success and aGuardClause of TRUE: aTrueFunc(aBoolean, aString); end;
  result := SELF;
end;

{ TAction }

constructor TAction.Create;
begin
  raise exception.create('Don''t call TAction.create');
end;

constructor TAction.Create(const aProcNIL: pointer);
begin
  case aProcNIL = NIL of   TRUE: EXIT;
                          FALSE: raise exception.Create('Methodless constructor must be called with NIL'); end;
end;
constructor TAction.Create(const aProcBooleanString: TAProcBooleanString);
begin
  FAProcBooleanString  := aProcBooleanString;
  methodAssigned       := assigned(aProcBooleanString);
end;

class function TAction.pick(const aBoolean: boolean; const aTrueProc: TAProcBooleanString): TAction;
begin
  case aBoolean of
     TRUE:  result := TAction.Create(aTrueProc);
    FALSE:  result := TAction.Create(NIL);
  end;
end;

class function TAction.pick(const aBoolean: boolean; const aTrueProc: TAProcBooleanString; const aFalseProc: TAProcBooleanString): TAction;
begin
  case aBoolean of
     TRUE:  result := TAction.Create(aTrueProc);
    FALSE:  result := TAction.Create(aFalseProc);
  end;
end;


procedure TAction.perform(const aBoolean: boolean; const aString: string);
begin
  try
    case assigned(FAProcBooleanString) of TRUE: FAProcBooleanString(aBoolean, aString); end;
  finally
    SELF.free;
  end;
end;

end.
