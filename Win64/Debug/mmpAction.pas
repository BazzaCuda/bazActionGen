{   bazLib / bazAction
    Copyright (C) 2021-2099 Baz Cuda
    https://github.com/BazzaCuda/

    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307, USA
}
unit mmpAction;

interface

{ THIS UNIT IS GENERATED BY bazActionGen.exe. AMEND THE bazActionDefs.txt FILE TO REGENERATE THIS UNIT FOR DIFFERENT FUNCTION TYPES AND FUNCTION SIGNATURES }
{ These are project-specific datatypes added via identically-named descendants of bazAction.IAction and bazAction.TAction }

uses
  bazAction;
  
type
  TVoid = bazAction.TVoid;

  TOFuncBooleanString       <TResult> = function(const aBoolean: boolean; const aString: string):                       TResult of object; // method of class instance
  TSFuncBooleanString       <TResult> = function(const aBoolean: boolean; const aString: string):                       TResult;           // static method - no class instance
  TAFuncBooleanString       <TResult> = reference to function(const aBoolean: boolean; const aString: string):          TResult;           // anonymous method

  IAction<TResult> = interface(bazAction.IAction<TResult>)
    function default(const aValue: TResult): IAction<TResult>; // the fallback value

    function perform(const aBoolean: boolean; const aString: string):                      TResult; overload;

    function getAssigned: boolean;
    property assigned:    boolean read getAssigned;
  end;

  TAction<TResult> = class(bazAction.TAction<TResult>, bazAction.IAction<TResult>)
  strict private
    FFuncAssigned: boolean;
    FDefault:      TResult; // initialised by constructor, set by optional .default(), used in .perform()

    FOFuncBooleanString:                TOFuncBooleanString                  <TResult>;
    FSFuncBooleanString:                TAFuncBooleanString                  <TResult>;
    FAFuncBooleanString:                TAFuncBooleanString                  <TResult>;

    constructor Create;                           overload;
    constructor Create(const aFuncNIL: pointer);  overload;

    constructor Create(const aFuncBooleanString:     TOFuncBooleanString      <TResult>);     overload;
    constructor Create(const aFuncBooleanString:     TSFuncBooleanString      <TResult>);     overload;
    constructor Create(const aFuncBooleanString:     TAFuncBooleanString      <TResult>);     overload;

  public
    function getAssigned: boolean;
    function default(const aValue: TResult): IAction<TResult>;

    class function pick(const aBoolean: boolean; const aTrueFuncBooleanString:      TOFuncBooleanString      <TResult>):           IAction<TResult>; overload;
    class function pick(const aBoolean: boolean; const aTrueFuncBooleanString:      TSFuncBooleanString      <TResult>):           IAction<TResult>; overload;
    class function pick(const aBoolean: boolean; const aTrueFuncBooleanString:      TAFuncBooleanString      <TResult>):           IAction<TResult>; overload;

    function perform(const aBoolean: boolean; const aString: string):            TResult; overload;
  end;

implementation

uses
  bazRTL;

{ TAction<TResult> }

constructor TAction<TResult>.Create;
begin
  raise exception.create('Don''t call TAction.create');
end;

constructor TAction<TResult>.Create(const aFuncNIL: pointer);
begin
  case aFuncNIL = NIL of   TRUE: EXIT;
                          FALSE: raise exception.Create('Functionless constructor must be called with NIL'); end;
end;

constructor TAction<TResult>.Create(const aFuncBooleanString: TOFuncBooleanString<TResult>);
begin
  FOFuncBooleanString  := aFuncBooleanString;
  FFuncAssigned        := assigned(aFuncBooleanString);
end;

constructor TAction<TResult>.Create(const aFuncBooleanString: TSFuncBooleanString<TResult>);
begin
  FSFuncBooleanString  := aFuncBooleanString;
  FFuncAssigned        := assigned(aFuncBooleanString);
end;

constructor TAction<TResult>.Create(const aFuncBooleanString: TAFuncBooleanString<TResult>);
begin
  FAFuncBooleanString  := aFuncBooleanString;
  FFuncAssigned        := assigned(aFuncBooleanString);
end;

class function TAction<TResult>.pick(const aBoolean: boolean; const aTrueFuncBooleanString: TOFuncBooleanString<TResult>): IAction<TResult>;
begin
  case aBoolean of
     TRUE:  result := IAction<TResult>(pointer(TAction<TResult>.Create(aTrueFuncBooleanString)));
    FALSE:  result := IAction<TResult>(pointer(TAction<TResult>.Create(NIL)));
  end;
end;

class function TAction<TResult>.pick(const aBoolean: boolean; const aTrueFuncBooleanString: TSFuncBooleanString<TResult>): IAction<TResult>;
begin
  case aBoolean of
     TRUE:  result := IAction<TResult>(pointer(TAction<TResult>.Create(aTrueFuncBooleanString)));
    FALSE:  result := IAction<TResult>(pointer(TAction<TResult>.Create(NIL)));
  end;
end;

class function TAction<TResult>.pick(const aBoolean: boolean; const aTrueFuncBooleanString: TAFuncBooleanString<TResult>): IAction<TResult>;
begin
  case aBoolean of
     TRUE:  result := IAction<TResult>(pointer(TAction<TResult>.Create(aTrueFuncBooleanString)));
    FALSE:  result := IAction<TResult>(pointer(TAction<TResult>.Create(NIL)));
  end;
end;

function TAction<TResult>.getAssigned: boolean;
begin
  result := FFuncAssigned;
end;

function TAction<TResult>.default(const aValue: TResult): IAction<TResult>;
begin
  FDefault := aValue;
  result   := IAction<TResult>(pointer(SELF));
end;

function TAction<TResult>.perform(const aBoolean: boolean; const aString: string): TResult;
begin
  result := FDefault;
  case assigned(FOFuncBooleanString) of TRUE: EXIT(FOFuncBooleanString(aBoolean, aString)); end;
  case assigned(FSFuncBooleanString) of TRUE: EXIT(FSFuncBooleanString(aBoolean, aString)); end;
  case assigned(FAFuncBooleanString) of TRUE: EXIT(FAFuncBooleanString(aBoolean, aString)); end;
end;

end.
