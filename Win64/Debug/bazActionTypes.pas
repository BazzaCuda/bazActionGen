unit bazActionTypes;

interface

{ THIS UNIT IS GENERATED BY bazActionGen.exe. AMEND THE bazActionDefs.txt FILE TO REGENERATE THIS UNIT FOR DIFFERENT FUNCTION TYPES AND FUNCTION SIGNATURES }
{ These are project-specific datatypes added via identically-named descendants of bazAction.TAction }

type
  TVoid = bazAction.TVoid;

  TFunc<T> = reference to function: T;
  TAFuncbazActionTypes      <TResult> = reference to function():                                                        TResult;

  TAProcbazActionTypes       = reference to procedure()                                                        ;

  TAction<TResult> = class(bazAction.TAction<TResult>)

    FAFuncbazActionTypes:               TAFuncbazActionTypes                 <TResult>;

    constructor Create;                           overload;
    constructor Create(const aFuncNIL: pointer);  overload;
    constructor Create(const aFuncbazActionTypes:    TAFuncbazActionTypes     <TResult>);     overload;

    class function pick(const aBoolean: boolean; const aTrueFunc: TAFuncbazActionTypes                                                  <TResult>): TAction<TResult>; overload;

    class function pick(const aBoolean: boolean; const aTrueFunc: TAFuncbazActionTypes<TResult>; const aFalseFunc: TAFuncbazActionTypes <TResult>): TAction<TResult>; overload;

    function  perform(): TResult; overload;


    function  andThen(const aGuardClause: boolean; const aTrueFunc: TAFuncbazActionTypes<boolean>): TAction<TResult>; overload;

    function  aside(const aGuardClause: boolean; const aTrueFunc: TAFuncbazActionTypes<boolean>): TAction<TResult>; overload;

    function  aside<T>(const aGuardClause: boolean; const aTrueFunc: TAFuncbazActionTypes<T>): TAction<TResult>; overload;
  end;

  TAction = class(bazAction.TAction)

    FAProcbazActionTypes:               TAProcbazActionTypes                 ;

    constructor Create;                           overload;
    constructor Create(const aProcNIL: pointer);  overload;
    constructor Create(const aProcbazActionTypes:    TAProcbazActionTypes      );     overload;


    class function pick(const aBoolean: boolean; const aTrueProc: TAProcbazActionTypes                                                  ): TAction; overload;
    class function pick(const aBoolean: boolean; const aTrueProc: TAProcbazActionTypes; const aFalseProc: TAProcbazActionTypes          ): TAction; overload;

    procedure  perform(); overload;




  end;

implementation

uses
  bazRTL;

{ TAction<TResult> }

constructor TAction<TResult>.Create;
begin
  raise exception.create('Don''t call TAction.create');
end;

constructor TAction<TResult>.Create(const aFuncNIL: pointer);
begin
  case aFuncNIL = NIL of   TRUE: EXIT;
                          FALSE: raise exception.Create('Methodless constructor must be called with NIL'); end;
end;
constructor TAction<TResult>.Create(const aFuncbazActionTypes: TAFuncbazActionTypes<TResult>);
begin
  FAFuncbazActionTypes := aFuncbazActionTypes;
  methodAssigned       := assigned(aFuncbazActionTypes);
end;

class function TAction<TResult>.pick(const aBoolean: boolean; const aTrueFunc: TAFuncbazActionTypes<TResult>): TAction<TResult>;
begin
  case aBoolean of
     TRUE:  result := TAction<TResult>.Create(aTrueFunc);
    FALSE:  result := TAction<TResult>.Create(NIL);
  end;
end;

class function TAction<TResult>.pick(const aBoolean: boolean; const aTrueFunc: TAFuncbazActionTypes<TResult>; const aFalseFunc: TAFuncbazActionTypes<TResult>): TAction<TResult>;
begin
  case aBoolean of
     TRUE:  result := TAction<TResult>.Create(aTrueFunc);
    FALSE:  result := TAction<TResult>.Create(aFalseFunc);
  end;
end;


function TAction<TResult>.perform(): TResult;
begin
  result := getDefault;
  try
    case assigned(FAFuncbazActionTypes) of TRUE: EXIT(FAFuncbazActionTypes()); end;
  finally
    SELF.free;
  end;
end;

function TAction<TResult>.andThen(const aGuardClause: boolean; const aTrueFunc: TAFuncbazActionTypes<boolean>): TAction<TResult>;
begin
  case success and aGuardClause of TRUE: success := aTrueFunc(); end;
  result := SELF;
end;

function TAction<TResult>.aside(const aGuardClause: boolean; const aTrueFunc: TAFuncbazActionTypes<boolean>): TAction<TResult>;
begin
  case success and aGuardClause of TRUE: aTrueFunc(); end;
  result := SELF;
end;

function TAction<TResult>.aside<T>(const aGuardClause: boolean; const aTrueFunc: TAFuncbazActionTypes<T>): TAction<TResult>;
begin
  case success and aGuardClause of TRUE: aTrueFunc(); end;
  result := SELF;
end;

{ TAction }

constructor TAction.Create;
begin
  raise exception.create('Don''t call TAction.create');
end;

constructor TAction.Create(const aProcNIL: pointer);
begin
  case aProcNIL = NIL of   TRUE: EXIT;
                          FALSE: raise exception.Create('Methodless constructor must be called with NIL'); end;
end;
constructor TAction.Create(const aProcbazActionTypes: TAProcbazActionTypes);
begin
  FAProcbazActionTypes := aProcbazActionTypes;
  methodAssigned       := assigned(aProcbazActionTypes);
end;

class function TAction.pick(const aBoolean: boolean; const aTrueProc: TAProcbazActionTypes): TAction;
begin
  case aBoolean of
     TRUE:  result := TAction.Create(aTrueProc);
    FALSE:  result := TAction.Create(NIL);
  end;
end;

class function TAction.pick(const aBoolean: boolean; const aTrueProc: TAProcbazActionTypes; const aFalseProc: TAProcbazActionTypes): TAction;
begin
  case aBoolean of
     TRUE:  result := TAction.Create(aTrueProc);
    FALSE:  result := TAction.Create(aFalseProc);
  end;
end;


procedure TAction.perform();
begin
  try
    case assigned(FAProcbazActionTypes) of TRUE: FAProcbazActionTypes(); end;
  finally
    SELF.free;
  end;
end;

end.
