program bazActionGen;

{   bazActionGen
    Copyright (C) 2021-2099 Baz Cuda
    https://github.com/BazzaCuda/bazActionGen

    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307, USA
}

{$APPTYPE CONSOLE}

{$R *.res}

uses
  system.classes,
  system.generics.collections,
  system.sysUtils,
  vcl.dialogs,
  bazAction in 'Win64\Debug\bazAction.pas',
//  mmpAction in 'Win64\Debug\mmpAction.pas',
  bazRTL in '..\_MVVM\_bazLib\bazRTL.pas';

type
  TDef = record
    suffix: string;
    paramDefs: string;
    paramList: string;
  end;

  TDefs = array of TDef;

  TVoid = record end;

  TFuncProc = (fpFunc, fpProc);

const
  BAZ_ACTION_UNIT   = 'bazAction';
  FILE_PATH_IN      = 'bazActionDefs.txt';
  FILE_PATH_OUT     = 'bazAction.pas';

var
  vDefs: TDefs;
  vUnit: string = '';

procedure writeUnitHeader(const aSL: TStringList);
begin
//  aSL.add('''
//{   bazLib / bazAction
//    Copyright (C) 2021-2099 Baz Cuda
//    https://github.com/BazzaCuda/
//
//    This program is free software; you can redistribute it and/or modify
//    it under the terms of the GNU General Public License as published by
//    the Free Software Foundation; either version 3 of the License, or
//    (at your option) any later version.
//
//    This program is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//    GNU General Public License for more details.
//
//    You should have received a copy of the GNU General Public License
//    along with this program; if not, write to the Free Software
//    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307, USA
//
//''' + '}');
//  aSL.add('unit bazAction;');

  aSL.add('');
  aSL.add('interface');
  aSL.add('');
  aSL.add('{ THIS UNIT IS GENERATED BY bazActionGen.exe. AMEND THE bazActionDefs.txt FILE TO REGENERATE THIS UNIT FOR DIFFERENT FUNCTION TYPES AND FUNCTION SIGNATURES }');
  case vUnit = BAZ_ACTION_UNIT of  TRUE: aSL.add('{ Add project-specific datatypes to IAction and TAction descendants in a separate unit }');
                                  FALSE: aSL.add('{ These are project-specific datatypes added via identically-named descendants of bazAction.IAction and bazAction.TAction }'); end;
  aSL.add('');
end;

procedure writeTypes(const aDefs: TDefs; const aSL: TStringList; const aFuncProc: TFuncProc);
const
  WIDTH_SUFFIX = 20;
  WIDTH_PARAMS = 80;
begin
  case aFuncProc of fpFunc: begin
                              aSL.add('type');
                              case vUnit = BAZ_ACTION_UNIT of  TRUE: aSL.add('  TVoid = record end;');
                                                              FALSE: aSL.add('  TVoid = bazAction.TVoid;'); end;end;end;
  aSL.add('');

  var vFuncPrefix := '';

  var vResult1            := '';
  var vResult2            := '';
  var vFuncProc           := 'Proc';
  var vFunctionProcedure  := 'procedure';
  case aFuncProc of fpFunc: begin
                              vFunctionProcedure  := 'function';
                              vFuncProc           := 'Func';
                              vResult1            := '<TResult>';
                              vResult2            := 'TResult'; end;end;

  var vColon := '';
  case aFuncProc of fpFunc: vColon := ':'; end;

  aSL.add('');
  case (aFuncProc = fpFunc) and (vUnit = BAZ_ACTION_UNIT) of TRUE: aSL.add('  TFunc<T> = reference to function: T;'); end;

  for var i := 0 to length(aDefs) - 1 do begin
    aSL.add('');
    vFuncPrefix := format('%s(' + aDefs[i].paramDefs + ')%s', [vFunctionProcedure, vColon]);
    aSL.add(format('  TO%s%-*s%s = %-*s%s of object; // method of class instance', [vFuncProc, WIDTH_SUFFIX, aDefs[i].suffix, vResult1, WIDTH_PARAMS, vFuncPrefix, vResult2]));

    vFuncPrefix := format('%s(' + aDefs[i].paramDefs + ')%s', [vFunctionProcedure, vColon]);
    aSL.add(format('  TS%s%-*s%s = %-*s%s;           // static method - no class instance', [vFuncProc, WIDTH_SUFFIX, aDefs[i].suffix, vResult1, WIDTH_PARAMS, vFuncPrefix, vResult2]));

    vFuncPrefix := format('reference to %s(' + aDefs[i].paramDefs + ')%s', [vFunctionProcedure, vColon]);
    aSL.add(format('  TA%s%-*s%s = %-*s%s;           // anonymous method', [vFuncProc, WIDTH_SUFFIX, aDefs[i].suffix, vResult1, WIDTH_PARAMS, vFuncPrefix, vResult2]));
  end;
end;

procedure writeInterface(const aDefs: TDefs; const aSL: TStringList; const aFuncProc: TFuncProc);
const
  WIDTH_PARAMS = 4;
begin
  var vResult1            := '';
  var vResult2            := '';
  var vColon              := '';
  var vFunctionProcedure  := 'procedure';
  var vIAction            := '';

  case aFuncProc of fpFunc: begin
                              vIAction            := 'IAction';
                              vFunctionProcedure  := 'function';
                              vColon              := ': ';
                              vResult1            := '<TResult>';
                              vResult2            := 'TResult'; end;end;

  aSL.add('');
  case vUnit = BAZ_ACTION_UNIT of  TRUE: aSL.add(format('  IAction%s = interface', [vResult1]));
                                  FALSE: aSL.add(format('  IAction%s = interface(bazAction.IAction%s)', [vResult1, vResult1])); end;

  case (aFuncProc = fpFunc) and (vUnit = BAZ_ACTION_UNIT) of TRUE:  begin
                              aSL.add(format('    function  default(const aValue: %s): IAction%s; // the fallback value', [vResult2, vResult1])); // correct as a function
                              aSL.add(format('    function  getDefault: TResult;', [])); end;end;

  case (aFuncProc = fpFunc) and (vUnit = BAZ_ACTION_UNIT) of TRUE: aSL.add(format('    function  ensure(const aGuardClause: boolean): IAction%s;', [vResult1])); end;
  case (aFuncProc = fpFunc) and (vUnit = BAZ_ACTION_UNIT) of TRUE: aSL.add(format('    function  assign<T>(var aTarget: T; const aValue: T): IAction%s; overload;', [vResult1])); end;
  case (aFuncProc = fpFunc) and (vUnit = BAZ_ACTION_UNIT) of TRUE: aSL.add(format('    function  assign<T>(const aGuardClause: boolean; var aTarget: T; const aValue: T): IAction%s; overload;', [vResult1])); end;
  case (aFuncProc = fpFunc) and (vUnit = BAZ_ACTION_UNIT) of TRUE: aSL.add(format('    function  assign<T>(var aTarget: T; const aValue: TFunc<T>): IAction<TResult>; overload;', [])); end;
  case (aFuncProc = fpFunc) and (vUnit = BAZ_ACTION_UNIT) of TRUE: aSL.add(format('    function  assign<T>(const aGuardClause: boolean; var aTarget: T; const aValue: TFunc<T>): IAction<TResult>; overload;', [])); end;

  aSL.add('');
  for var i := 0 to length(aDefs) - 1 do
    aSL.add(format('    %s  perform(%s)%s; overload;', [vFunctionProcedure, aDefs[i].paramDefs, vColon + vResult2]));

  case                           (vUnit = BAZ_ACTION_UNIT) of TRUE:  begin
                                                                      aSL.add('');
                                                                      aSL.add('    function  getMethodAssigned: boolean;'); // correct as a function
                                                                      aSL.add('    procedure setMethodAssigned(const aValue: boolean);');
                                                                      aSL.add('    property  methodAssigned:    boolean read getMethodAssigned write setMethodAssigned;'); end;end;

  case (aFuncProc = fpFunc) and (vUnit = BAZ_ACTION_UNIT) of TRUE: begin
  aSL.add('');
  aSL.add('    function  getSuccess:  boolean;');
  aSL.add('    procedure setSuccess(const aValue: boolean);');
  aSL.add('    property  success:     boolean read getSuccess write setSuccess;');
  end;end;

  case aFuncProc of fpFunc: begin
    for var i := 0 to length(aDefs) - 1 do begin
       aSL.add('');
       aSL.add(format('    function  andThen(const aGuardClause: boolean; const aTrueFunc: TOFunc%s<TResult>; %s): IAction<TResult>; overload;', [aDefs[i].suffix, aDefs[i].paramDefs]));
       aSL.add(format('    function  andThen(const aGuardClause: boolean; const aTrueFunc: TSFunc%s<TResult>; %s): IAction<TResult>; overload;', [aDefs[i].suffix, aDefs[i].paramDefs]));
       aSL.add(format('    function  andThen(const aGuardClause: boolean; const aTrueFunc: TAFunc%s<TResult>; %s): IAction<TResult>; overload;', [aDefs[i].suffix, aDefs[i].paramDefs]));
    end;end;end;

  case aFuncProc of fpFunc: begin
    for var i := 0 to length(aDefs) - 1 do begin
       aSL.add('');
       aSL.add(format('    function  aside(const aGuardClause: boolean; const aTrueFunc: TOFunc%s<TResult>; %s): IAction<TResult>; overload;', [aDefs[i].suffix, aDefs[i].paramDefs]));
       aSL.add(format('    function  aside(const aGuardClause: boolean; const aTrueFunc: TSFunc%s<TResult>; %s): IAction<TResult>; overload;', [aDefs[i].suffix, aDefs[i].paramDefs]));
       aSL.add(format('    function  aside(const aGuardClause: boolean; const aTrueFunc: TAFunc%s<TResult>; %s): IAction<TResult>; overload;', [aDefs[i].suffix, aDefs[i].paramDefs]));
    end;end;end;

    case (aFuncProc = fpFunc) and (vUnit = BAZ_ACTION_UNIT) of TRUE:  begin
                                                                        aSL.add('');
                                                                        aSL.add('    function  thenStop: boolean;'); end;end;
  aSL.add('  end;');
end;

procedure writeClassHeader(const aDefs: TDefs; const aSL: TStringList; const aFuncProc: TFuncProc);
begin
  var vResult1            := '';
  case aFuncProc of fpFunc: vResult1 := '<TResult>'; end;

  aSL.add('');
  case vUnit = BAZ_ACTION_UNIT of  TRUE: aSL.add(format('  TAction%s = class(TInterfacedObject, IAction%s)', [vResult1, vResult1]));
                                  FALSE: aSL.add(format('  TAction%s = class(bazAction.TAction%s, %s.IAction%s)', [vResult1, vResult1, vUnit, vResult1])); end;
end;

procedure writeClassMembers(const aDefs: TDefs; const aSL: TStringList; const aFuncProc: TFuncProc);
const
  WIDTH_SUFFIX = 30;
begin
  case                          (vUnit = BAZ_ACTION_UNIT) of TRUE:  begin
                                                                      aSL.add('  strict private');
                                                                      aSL.add('    FMethodAssigned: boolean;');
                                                                      case aFuncProc of fpFunc: begin
                                                                           aSL.add('    FSuccess:        boolean;');
                                                                           aSL.add('    FDefault:        TResult; // initialised by constructor, set by optional .default(), used in .perform()'); end;end;end;end;

  var vFuncProc := 'Proc';
  var vResult1  := '';
  case aFuncProc of fpFunc: begin
                              vFuncProc := 'Func';
                              vResult1  := '<TResult>';  end;end;

  for var i := 0 to high(aDefs) do
  begin
    aSL.add('');
    aSL.add(format('    FO%s%-*sTO%s%-*s %s;', [vFuncProc, WIDTH_SUFFIX, aDefs[i].suffix + ':', vFuncProc, WIDTH_SUFFIX, aDefs[i].suffix, vResult1]));
    aSL.add(format('    FS%s%-*sTA%s%-*s %s;', [vFuncProc, WIDTH_SUFFIX, aDefs[i].suffix + ':', vFuncProc, WIDTH_SUFFIX, aDefs[i].suffix, vResult1]));
    aSL.add(format('    FA%s%-*sTA%s%-*s %s;', [vFuncProc, WIDTH_SUFFIX, aDefs[i].suffix + ':', vFuncProc, WIDTH_SUFFIX, aDefs[i].suffix, vResult1]));
  end;
end;

procedure writeClassConstructors(const aDefs: TDefs; const aSL: TStringList; const aFuncProc: TFuncProc);
const
  WIDTH_PARAM_NAME  = 30;
  WIDTH_FUNC_TYPE   = 25;
  WIDTH_GENERIC     = 1;
begin
  var vFuncProc := 'Proc';
  case aFuncProc of fpFunc: vFuncProc := 'Func'; end;

  aSL.add('    constructor Create;                           overload;');
  aSL.add(format('    constructor Create(const a%sNIL: pointer);  overload;', [vFuncProc]));
  aSL.add('');

  case aFuncProc of fpFunc:
  for var i := 0 to high(aDefs) do
  begin
    aSL.add(format('    constructor Create(%-*s%-*s%-*s);     overload;', [WIDTH_PARAM_NAME, 'const aFunc' + aDefs[i].suffix + ':', WIDTH_FUNC_TYPE, 'TOFunc' + aDefs[i].suffix, WIDTH_GENERIC, '<TResult>']));
    aSL.add(format('    constructor Create(%-*s%-*s%-*s);     overload;', [WIDTH_PARAM_NAME, 'const aFunc' + aDefs[i].suffix + ':', WIDTH_FUNC_TYPE, 'TSFunc' + aDefs[i].suffix, WIDTH_GENERIC, '<TResult>']));
    aSL.add(format('    constructor Create(%-*s%-*s%-*s);     overload;', [WIDTH_PARAM_NAME, 'const aFunc' + aDefs[i].suffix + ':', WIDTH_FUNC_TYPE, 'TAFunc' + aDefs[i].suffix, WIDTH_GENERIC, '<TResult>']));
    aSL.add('');
  end;end;

  case aFuncProc of fpProc:
  for var i := 0 to high(aDefs) do
  begin
    aSL.add(format('    constructor Create(%-*s%-*s%-*s);     overload;', [WIDTH_PARAM_NAME, 'const aProc' + aDefs[i].suffix + ':', WIDTH_FUNC_TYPE, 'TOProc' + aDefs[i].suffix, WIDTH_GENERIC, '']));
    aSL.add(format('    constructor Create(%-*s%-*s%-*s);     overload;', [WIDTH_PARAM_NAME, 'const aProc' + aDefs[i].suffix + ':', WIDTH_FUNC_TYPE, 'TSProc' + aDefs[i].suffix, WIDTH_GENERIC, '']));
    aSL.add(format('    constructor Create(%-*s%-*s%-*s);     overload;', [WIDTH_PARAM_NAME, 'const aProc' + aDefs[i].suffix + ':', WIDTH_FUNC_TYPE, 'TAProc' + aDefs[i].suffix, WIDTH_GENERIC, '']));
    aSL.add('');
  end;end;
end;

procedure writeClassPicks(const aDefs: TDefs; const aSL: TStringList; const aFuncProc: TFuncProc);
const
  WIDTH_PARAM_NAME  = 1;
  WIDTH_FUNC_TYPE   = 2;
begin
  var vResult1 := '';
  var vResult2 := '';
  case aFuncProc of fpFunc: begin
                              vResult1 := '<TResult>';
                              vResult2 := 'TResult'; end;end;

  case                          (vUnit = BAZ_ACTION_UNIT) of TRUE:  begin
                                                                      aSL.add('  public');
                                                                      aSL.add('    function  getMethodAssigned: boolean;');
                                                                      aSL.add('    procedure setMethodAssigned(const aValue: boolean);');
                                                                      case aFuncProc of fpFunc: begin
                                                                          aSL.add('    function  getSuccess:        boolean;');
                                                                          aSL.add('    procedure setSuccess(const aValue: boolean);');
                                                                          aSL.add('    function  default(const aValue: TResult): IAction<TResult>;');
                                                                          aSL.add('    function  getDefault: TResult;'); end;end;end;end;

  case (aFuncProc = fpFunc) and (vUnit = BAZ_ACTION_UNIT) of TRUE: aSL.add(format('    function  ensure(const aGuardClause: boolean): IAction%s;', [vResult1])); end;
  case (aFuncProc = fpFunc) and (vUnit = BAZ_ACTION_UNIT) of TRUE: aSL.add(format('    function  assign<T>(var aTarget: T; const aValue: T): IAction%s; overload;', [vResult1])); end;
  case (aFuncProc = fpFunc) and (vUnit = BAZ_ACTION_UNIT) of TRUE: aSL.add(format('    function  assign<T>(const aGuardClause: boolean; var aTarget: T; const aValue: T): IAction%s; overload;', [vResult1])); end;
  case (aFuncProc = fpFunc) and (vUnit = BAZ_ACTION_UNIT) of TRUE: aSL.add(format('    function  assign<T>(var aTarget: T; const aValue: TFunc<T>): IAction<TResult>; overload;', [])); end;
  case (aFuncProc = fpFunc) and (vUnit = BAZ_ACTION_UNIT) of TRUE: aSL.add(format('    function  assign<T>(const aGuardClause: boolean; var aTarget: T; const aValue: TFunc<T>): IAction<TResult>; overload;', [])); end;

  aSL.add('');

  case aFuncProc of fpFunc:
  for var i := 0 to high(aDefs) do
  begin
    aSL.add(format('    class function pick(%-*s%-*s<TResult>): IAction<TResult>; overload;', [WIDTH_PARAM_NAME, 'const aBoolean: boolean; const aTrueFunc' + ': ', WIDTH_FUNC_TYPE, 'TOFunc' + aDefs[i].suffix]));
    aSL.add(format('    class function pick(%-*s%-*s<TResult>): IAction<TResult>; overload;', [WIDTH_PARAM_NAME, 'const aBoolean: boolean; const aTrueFunc' + ': ', WIDTH_FUNC_TYPE, 'TSFunc' + aDefs[i].suffix]));
    aSL.add(format('    class function pick(%-*s%-*s<TResult>): IAction<TResult>; overload;', [WIDTH_PARAM_NAME, 'const aBoolean: boolean; const aTrueFunc' + ': ', WIDTH_FUNC_TYPE, 'TAFunc' + aDefs[i].suffix]));
    aSL.add('');
    aSL.add(format('    class function pick(%-*s%-*s<TResult>): IAction<TResult>; overload;', [WIDTH_PARAM_NAME, 'const aBoolean: boolean; const aTrueFunc' + ': ', WIDTH_FUNC_TYPE, 'TOFunc' + aDefs[i].suffix + '<TResult>; const aFalseFunc' + ': TOFunc' + aDefs[i].suffix]));
    aSL.add(format('    class function pick(%-*s%-*s<TResult>): IAction<TResult>; overload;', [WIDTH_PARAM_NAME, 'const aBoolean: boolean; const aTrueFunc' + ': ', WIDTH_FUNC_TYPE, 'TSFunc' + aDefs[i].suffix + '<TResult>; const aFalseFunc' + ': TSFunc' + aDefs[i].suffix]));
    aSL.add(format('    class function pick(%-*s%-*s<TResult>): IAction<TResult>; overload;', [WIDTH_PARAM_NAME, 'const aBoolean: boolean; const aTrueFunc' + ': ', WIDTH_FUNC_TYPE, 'TAFunc' + aDefs[i].suffix + '<TResult>; const aFalseFunc' + ': TAFunc' + aDefs[i].suffix]));
    aSL.add('');
  end;end;

  case aFuncProc of fpProc:
  for var i := 0 to high(aDefs) do
  begin
    aSL.add(format('    class function pick(%-*s%-*s): IAction; overload;', [WIDTH_PARAM_NAME, 'const aBoolean: boolean; const aTrueProc' + ': ', WIDTH_FUNC_TYPE, 'TOProc' + aDefs[i].suffix]));
    aSL.add(format('    class function pick(%-*s%-*s): IAction; overload;', [WIDTH_PARAM_NAME, 'const aBoolean: boolean; const aTrueProc' + ': ', WIDTH_FUNC_TYPE, 'TSProc' + aDefs[i].suffix]));
    aSL.add(format('    class function pick(%-*s%-*s): IAction; overload;', [WIDTH_PARAM_NAME, 'const aBoolean: boolean; const aTrueProc' + ': ', WIDTH_FUNC_TYPE, 'TAProc' + aDefs[i].suffix]));
    aSL.add('');
    aSL.add(format('    class function pick(%-*s%-*s): IAction; overload;', [WIDTH_PARAM_NAME, 'const aBoolean: boolean; const aTrueProc' + ': ', WIDTH_FUNC_TYPE, 'TOProc' + aDefs[i].suffix + '; const aFalseProc' + ': TOProc' + aDefs[i].suffix]));
    aSL.add(format('    class function pick(%-*s%-*s): IAction; overload;', [WIDTH_PARAM_NAME, 'const aBoolean: boolean; const aTrueProc' + ': ', WIDTH_FUNC_TYPE, 'TSProc' + aDefs[i].suffix + '; const aFalseProc' + ': TSProc' + aDefs[i].suffix]));
    aSL.add(format('    class function pick(%-*s%-*s): IAction; overload;', [WIDTH_PARAM_NAME, 'const aBoolean: boolean; const aTrueProc' + ': ', WIDTH_FUNC_TYPE, 'TAProc' + aDefs[i].suffix + '; const aFalseProc' + ': TAProc' + aDefs[i].suffix]));
    aSL.add('');
  end;end;
end;

procedure writeClassPerforms(const aDefs: TDefs; const aSL: TStringList; const aFuncProc: TFuncProc);
const
  WIDTH_PARAMs  = 60;
begin
  var vResult2            := '';
  var vColon              := '';
  var vFunctionProcedure  := 'procedure';
  case aFuncProc of fpFunc: begin
                              vFunctionProcedure  := 'function';
                              vColon              := ': ';
                              vResult2            := 'TResult'; end;end;

  for var i := 0 to high(aDefs) do
    aSL.add(format('    %s  perform(%s)%s; overload;', [vFunctionProcedure, aDefs[i].paramDefs, vColon + vResult2]));


  aSL.add('');
  case (aFuncProc = fpFunc) and (vUnit = BAZ_ACTION_UNIT) of TRUE: aSL.add('    class function startWith(const aBoolean: boolean): IAction<TResult>;'); end;
  case (aFuncProc = fpFunc) and (vUnit = BAZ_ACTION_UNIT) of TRUE: aSL.add('    class function startWithNot(const aBoolean: boolean): IAction<TResult>;'); end;

  case aFuncProc of fpFunc:
    for var i := 0 to length(aDefs) - 1 do begin
       aSL.add('');
       aSL.add(format('    function  andThen(const aGuardClause: boolean; const aTrueFunc: TOFunc%s<TResult>; %s): IAction<TResult>; overload;', [aDefs[i].suffix, aDefs[i].paramDefs]));
       aSL.add(format('    function  andThen(const aGuardClause: boolean; const aTrueFunc: TSFunc%s<TResult>; %s): IAction<TResult>; overload;', [aDefs[i].suffix, aDefs[i].paramDefs]));
       aSL.add(format('    function  andThen(const aGuardClause: boolean; const aTrueFunc: TAFunc%s<TResult>; %s): IAction<TResult>; overload;', [aDefs[i].suffix, aDefs[i].paramDefs]));
    end;end;

  case aFuncProc of fpFunc:
    for var i := 0 to length(aDefs) - 1 do begin
       aSL.add('');
       aSL.add(format('    function  aside(const aGuardClause: boolean; const aTrueFunc: TOFunc%s<TResult>; %s): IAction<TResult>; overload;', [aDefs[i].suffix, aDefs[i].paramDefs]));
       aSL.add(format('    function  aside(const aGuardClause: boolean; const aTrueFunc: TSFunc%s<TResult>; %s): IAction<TResult>; overload;', [aDefs[i].suffix, aDefs[i].paramDefs]));
       aSL.add(format('    function  aside(const aGuardClause: boolean; const aTrueFunc: TAFunc%s<TResult>; %s): IAction<TResult>; overload;', [aDefs[i].suffix, aDefs[i].paramDefs]));
    end;end;

  case (aFuncProc = fpFunc) and (vUnit = BAZ_ACTION_UNIT) of TRUE:  begin
                                                                      aSL.add('');
                                                                      aSL.add('    function  thenStop: boolean;');
                                                                      aSL.add('');
                                                                      aSL.add('    property  success:        boolean read getSuccess         write setSuccess;'); end;end;

   case vUnit = BAZ_ACTION_UNIT of TRUE: aSL.add('    property  methodAssigned: boolean read getMethodAssigned  write setMethodAssigned;'); end;

  aSL.add('  end;');
end;

procedure writeImplementationHeader(const aSL: TStringList; const aFuncProc: TFuncProc);
begin
  var vResult1 := '';
  case aFuncProc of fpFunc: vResult1 := '<TResult>'; end;
  aSL.add('');
  aSL.add('implementation');
  aSL.add('');

  case aFuncProc of fpFunc: begin
                              aSL.add('uses');
                              aSL.add('  bazRTL;'); end;end;
end;

procedure writeConstructorsFixed(aDefs: TDefs; const aSL: TStringList; const aFuncProc: TFuncProc);
begin
  var vResult1  := '';
  var vFuncProc := 'Proc';
  case aFuncProc of fpFunc: begin
                              vResult1 := '<TResult>';
                              vFuncProc := 'Func'; end;end;


  aSL.add('');
  aSL.add(format('{ TAction%s }', [vResult1]));

  aSL.add('');
  aSL.add(format('constructor TAction%s.Create;', [vResult1]));
  aSL.add('begin');
  aSL.add('  raise exception.create(''Don''''t call TAction.create'');');
  aSL.add('end;');
  aSL.add('');

  aSL.add(format('constructor TAction%s.Create(const a%sNIL: pointer);', [vResult1, vFuncProc]));
  aSL.add('begin');
  aSL.add(format('  case a%sNIL = NIL of   TRUE: EXIT;', [vFuncProc]));
  aSL.add('                          FALSE: raise exception.Create(''Methodless constructor must be called with NIL''); end;');
  aSL.add('end;');
end;

procedure writeConstructors(const aDefs: TDefs; const aSL: TStringList; const aFuncProc: TFuncProc);
const
  WIDTH_PARAM_NAME  = 16;
  WIDTH_FUNC_TYPE   = 10;
  WIDTH_FIELD_NAME  = 20;
begin
  case aFuncProc of fpFunc:
  for var i := 0 to high(aDefs) do
  begin
    aSL.add(format('constructor TAction<TResult>.Create(const aFunc%s: TOFunc%s<TResult>);', [aDefs[i].suffix, aDefs[i].suffix]));
    aSL.add('begin');
    aSL.add(format('  %-*s := aFunc%s;', [WIDTH_FIELD_NAME, 'FOFunc' + aDefs[i].suffix, aDefs[i].suffix]));
    aSL.add(format('  %-*s := assigned(aFunc%s);', [WIDTH_FIELD_NAME, 'methodAssigned', aDefs[i].suffix]));
    aSL.add('end;');
    aSL.add('');

    aSL.add(format('constructor TAction<TResult>.Create(const aFunc%s: TSFunc%s<TResult>);', [aDefs[i].suffix, aDefs[i].suffix]));
    aSL.add('begin');
    aSL.add(format('  %-*s := aFunc%s;', [WIDTH_FIELD_NAME, 'FSFunc' + aDefs[i].suffix, aDefs[i].suffix]));
    aSL.add(format('  %-*s := assigned(aFunc%s);', [WIDTH_FIELD_NAME, 'methodAssigned', aDefs[i].suffix]));
    aSL.add('end;');
    aSL.add('');

    aSL.add(format('constructor TAction<TResult>.Create(const aFunc%s: TAFunc%s<TResult>);', [aDefs[i].suffix, aDefs[i].suffix]));
    aSL.add('begin');
    aSL.add(format('  %-*s := aFunc%s;', [WIDTH_FIELD_NAME, 'FAFunc' + aDefs[i].suffix, aDefs[i].suffix]));
    aSL.add(format('  %-*s := assigned(aFunc%s);', [WIDTH_FIELD_NAME, 'methodAssigned', aDefs[i].suffix]));
    aSL.add('end;');
    aSL.add('');
  end;end;

  case aFuncProc of fpProc:
  for var i := 0 to high(aDefs) do
  begin
    aSL.add(format('constructor TAction.Create(const aProc%s: TOProc%s);', [aDefs[i].suffix, aDefs[i].suffix]));
    aSL.add('begin');
    aSL.add(format('  %-*s := aProc%s;', [WIDTH_FIELD_NAME, 'FOProc' + aDefs[i].suffix, aDefs[i].suffix]));
    aSL.add(format('  %-*s := assigned(aProc%s);', [WIDTH_FIELD_NAME, 'methodAssigned', aDefs[i].suffix]));
    aSL.add('end;');
    aSL.add('');

    aSL.add(format('constructor TAction.Create(const aProc%s: TSProc%s);', [aDefs[i].suffix, aDefs[i].suffix]));
    aSL.add('begin');
    aSL.add(format('  %-*s := aProc%s;', [WIDTH_FIELD_NAME, 'FSProc' + aDefs[i].suffix, aDefs[i].suffix]));
    aSL.add(format('  %-*s := assigned(aProc%s);', [WIDTH_FIELD_NAME, 'methodAssigned', aDefs[i].suffix]));
    aSL.add('end;');
    aSL.add('');

    aSL.add(format('constructor TAction.Create(const aProc%s: TAProc%s);', [aDefs[i].suffix, aDefs[i].suffix]));
    aSL.add('begin');
    aSL.add(format('  %-*s := aProc%s;', [WIDTH_FIELD_NAME, 'FAProc' + aDefs[i].suffix, aDefs[i].suffix]));
    aSL.add(format('  %-*s := assigned(aProc%s);', [WIDTH_FIELD_NAME, 'methodAssigned', aDefs[i].suffix]));
    aSL.add('end;');
    aSL.add('');
  end;end;
end;

procedure writePicksTrueFunc(const aDefs: TDefs; const aSL: TStringList; const aFuncProc: TFuncProc);
begin
  var vResult1            := '';
  var vFuncProc           := 'Proc';
  var vFunctionProcedure  := 'procedure';
  case aFuncProc of fpFunc: begin
                              vResult1 := '<TResult>';
                              vFuncProc := 'Func';
                              vFunctionProcedure := 'function'; end;end;

  // picks are always functions
  for var i := 0 to high(aDefs) do
  begin
    aSL.add(format('class function TAction%s.pick(const aBoolean: boolean; const aTrue%s: TO%s%s%s): IAction%s;', [vResult1, vFuncProc, vFuncProc, aDefs[i].suffix, vResult1, vResult1]));
    aSL.add('begin');
    aSL.add('  case aBoolean of');

    var vPointerPrefix: string := '';
    var vPointerSuffix: string := '';
    case vUnit = BAZ_ACTION_UNIT of FALSE: vPointerPrefix := format('IAction%s(pointer(', [vResult1]); end;
    case vUnit = BAZ_ACTION_UNIT of FALSE: vPointerSuffix := '))'; end;

    aSL.add(format('     TRUE:  result := %sTAction%s.Create(aTrue%s)%s;', [vPointerPrefix, vResult1, vFuncProc, vPointerSuffix]));
    aSL.add(format('    FALSE:  result := %sTAction%s.Create(NIL)%s;',     [vPointerPrefix, vResult1, vPointerSuffix]));
    aSL.add('  end;');
    aSL.add('end;');
    aSL.add('');

    aSL.add(format('class function TAction%s.pick(const aBoolean: boolean; const aTrue%s: TS%s%s%s): IAction%s;', [vResult1, vFuncProc, vFuncProc, aDefs[i].suffix, vResult1, vResult1]));
    aSL.add('begin');
    aSL.add('  case aBoolean of');
    aSL.add(format('     TRUE:  result := %sTAction%s.Create(aTrue%s)%s;', [vPointerPrefix, vResult1, vFuncProc, vPointerSuffix]));
    aSL.add(format('    FALSE:  result := %sTAction%s.Create(NIL)%s;',     [vPointerPrefix, vResult1, vPointerSuffix]));
    aSL.add('  end;');
    aSL.add('end;');
    aSL.add('');

    aSL.add(format('class function TAction%s.pick(const aBoolean: boolean; const aTrue%s: TA%s%s%s): IAction%s;', [vResult1, vFuncProc, vFuncProc, aDefs[i].suffix, vResult1, vResult1]));
    aSL.add('begin');
    aSL.add('  case aBoolean of');
    aSL.add(format('     TRUE:  result := %sTAction%s.Create(aTrue%s)%s;', [vPointerPrefix, vResult1, vFuncProc, vPointerSuffix]));
    aSL.add(format('    FALSE:  result := %sTAction%s.Create(NIL)%s;',     [vPointerPrefix, vResult1, vPointerSuffix]));
    aSL.add('  end;');
    aSL.add('end;');
    aSL.add('');
  end;
end;

procedure writePicksTrueFalseFunc(const aDefs: TDefs; const aSL: TStringList; const aFuncProc: TFuncProc);
begin
  var vResult1            := '';
  var vFuncProc           := 'Proc';
  var vFunctionProcedure  := 'procedure';
  case aFuncProc of fpFunc: begin
                              vResult1            := '<TResult>';
                              vFuncProc           := 'Func';
                              vFunctionProcedure  := 'function'; end;end;

  var vPointerPrefix: string := '';
  var vPointerSuffix: string := '';
  case vUnit = BAZ_ACTION_UNIT of FALSE: vPointerPrefix := format('IAction%s(pointer(', [vResult1]); end;
  case vUnit = BAZ_ACTION_UNIT of FALSE: vPointerSuffix := '))'; end;

  // picks are always functions
  for var i := 0 to high(aDefs) do
  begin
    aSL.add(format('class function TAction%s.pick(const aBoolean: boolean; const aTrue%s: TO%s%s%s; const aFalse%s: TO%s%s%s): IAction%s;', [vResult1, vFuncProc, vFuncProc, aDefs[i].suffix, vResult1, vFuncProc, vFuncProc, aDefs[i].suffix, vResult1, vResult1]));
    aSL.add('begin');
    aSL.add('  case aBoolean of');

    aSL.add(format('     TRUE:  result := %sTAction%s.Create(aTrue%s)%s;',  [vPointerPrefix, vResult1, vFuncProc, vPointerSuffix]));
    aSL.add(format('    FALSE:  result := %sTAction%s.Create(aFalse%s)%s;', [vPointerPrefix, vResult1, vFuncProc, vPointerSuffix]));
    aSL.add('  end;');
    aSL.add('end;');
    aSL.add('');

    aSL.add(format('class function TAction%s.pick(const aBoolean: boolean; const aTrue%s: TS%s%s%s; const aFalse%s: TS%s%s%s): IAction%s;', [vResult1, vFuncProc, vFuncProc, aDefs[i].suffix, vResult1, vFuncProc, vFuncProc, aDefs[i].suffix, vResult1, vResult1]));
    aSL.add('begin');
    aSL.add('  case aBoolean of');

    aSL.add(format('     TRUE:  result := %sTAction%s.Create(aTrue%s)%s;',  [vPointerPrefix, vResult1, vFuncProc, vPointerSuffix]));
    aSL.add(format('    FALSE:  result := %sTAction%s.Create(aFalse%s)%s;', [vPointerPrefix, vResult1, vFuncProc, vPointerSuffix]));
    aSL.add('  end;');
    aSL.add('end;');
    aSL.add('');

    aSL.add(format('class function TAction%s.pick(const aBoolean: boolean; const aTrue%s: TA%s%s%s; const aFalse%s: TA%s%s%s): IAction%s;', [vResult1, vFuncProc, vFuncProc, aDefs[i].suffix, vResult1, vFuncProc, vFuncProc, aDefs[i].suffix, vResult1, vResult1]));
    aSL.add('begin');
    aSL.add('  case aBoolean of');

    aSL.add(format('     TRUE:  result := %sTAction%s.Create(aTrue%s)%s;',  [vPointerPrefix, vResult1, vFuncProc, vPointerSuffix]));
    aSL.add(format('    FALSE:  result := %sTAction%s.Create(aFalse%s)%s;', [vPointerPrefix, vResult1, vFuncProc, vPointerSuffix]));
    aSL.add('  end;');
    aSL.add('end;');
    aSL.add('');
  end;
end;

procedure writePerforms(const aDefs: TDefs; const aSL: TStringList; const aFuncProc: TFuncProc);
begin
  var vResult1            := '';
  var vResult2            := '';
  var vColon              := '';
  var vFuncProc           := 'Proc';
  var vFunctionProcedure  := 'procedure';

  case aFuncProc of fpFunc: begin
                              vFunctionProcedure  := 'function';
                              vColon              := ': ';
                              vResult1            := '<TResult>';
                              vResult2            := 'TResult'; end;end;

  case                          (vUnit = BAZ_ACTION_UNIT) of TRUE:  begin
                                                                      aSL.add('');
                                                                      aSL.add(format('function TAction%s.getMethodAssigned: boolean;', [vResult1]));
                                                                      aSL.add('begin');
                                                                      aSL.add('  result := FMethodAssigned;');
                                                                      aSL.add('end;');
                                                                      aSL.add('');
                                                                      aSL.add(format('procedure TAction%s.setMethodAssigned(const aValue: boolean);', [vResult1]));
                                                                      aSL.add('begin');
                                                                      aSL.add('  FMethodAssigned := aValue;');
                                                                      aSL.add('end;'); end;end;

  var vPointerPrefix: string := '';
  var vPointerSuffix: string := '';
  case vUnit = BAZ_ACTION_UNIT of FALSE: vPointerPrefix := format('IAction%s(pointer(', [vResult1]); end;
  case vUnit = BAZ_ACTION_UNIT of FALSE: vPointerSuffix := '))'; end;

  case (aFuncProc = fpFunc) and (vUnit = BAZ_ACTION_UNIT) of TRUE:  begin
                                                                      aSL.add('');
                                                                      aSL.add(format('function TAction%s.default(const aValue: TResult): IAction%s;', [vResult1, vResult1]));
                                                                      aSL.add('begin');
                                                                      aSL.add('  FDefault := aValue;');
                                                                      aSL.add(format('  result   := %sSELF%s;', [vPointerPrefix, vPointerSuffix]));
                                                                      aSL.add('end;');
                                                                      aSL.add('');
                                                                      aSL.add(format('function TAction%s.getDefault: TResult;', [vResult1]));
                                                                      aSL.add('begin');
                                                                      aSL.add('  result := FDefault');
                                                                      aSL.add('end;'); end;end;

  case (aFuncProc = fpFunc) and (vUnit = BAZ_ACTION_UNIT) of TRUE:  begin         // needs to work in non-generic TAction too at some point
                                                                      aSL.add('');
                                                                      aSL.add(format('function TAction%s.ensure(const aGuardClause: boolean): IAction%s;', [vResult1, vResult1]));
                                                                      aSL.add('begin');
                                                                      aSL.add('  success := success and aGuardClause;');
                                                                      aSL.add('  result := SELF;');
                                                                      aSL.add('end;'); end;end;

  case (aFuncProc = fpFunc) and (vUnit = BAZ_ACTION_UNIT) of TRUE:  begin // needs to work in non-generic TAction too at some point
                                                                      aSL.add('');
                                                                      aSL.add('function TAction<TResult>.assign(var aTarget: TResult; const aValue: TResult): IAction<TResult>;');
                                                                      aSL.add('begin');
                                                                      aSL.add('  case success of TRUE: aTarget := aValue; end;');
                                                                      aSL.add('  result  := SELF;');
                                                                      aSL.add('end;'); end;end;

  case (aFuncProc = fpFunc) and (vUnit = BAZ_ACTION_UNIT) of TRUE:  begin // needs to work in non-generic TAction too at some point
                                                                      aSL.add('');
                                                                      aSL.add('function TAction<TResult>.assign(const aGuardClause: boolean; var aTarget: TResult; const aValue: TResult): IAction<TResult>;');
                                                                      aSL.add('begin');
                                                                      aSL.add('  case success and aGuardClause of TRUE: aTarget := aValue; end;');
                                                                      aSL.add('  result  := SELF;');
                                                                      aSL.add('end;'); end;end;

  case (aFuncProc = fpFunc) and (vUnit = BAZ_ACTION_UNIT) of TRUE:  begin // needs to work in non-generic TAction too at some point
                                                                      aSL.add('');
                                                                      aSL.add('function TAction<TResult>.assign(var aTarget: TResult; const aValue: TFunc<TResult>): IAction<TResult>;');
                                                                      aSL.add('begin');
                                                                      aSL.add('  case success of TRUE: aTarget := aValue(); end;');
                                                                      aSL.add('  result  := SELF;');
                                                                      aSL.add('end;'); end;end;

  case (aFuncProc = fpFunc) and (vUnit = BAZ_ACTION_UNIT) of TRUE:  begin // needs to work in non-generic TAction too at some point
                                                                      aSL.add('');
                                                                      aSL.add('function TAction<TResult>.assign(const aGuardClause: boolean; var aTarget: TResult; const aValue: TFunc<TResult>): IAction<TResult>;');
                                                                      aSL.add('begin');
                                                                      aSL.add('  case success and aGuardClause of TRUE: aTarget := aValue(); end;');
                                                                      aSL.add('  result  := SELF;');
                                                                      aSL.add('end;'); end;end;


  for var i := 0 to high(aDefs) do
  begin
    aSL.add('');
    aSL.add(format('%s TAction%s.perform(' + aDefs[i].paramDefs + ')%s%s;', [vFunctionProcedure, vResult1, vColon, vResult2]));
    aSL.add('begin');
    case aFuncProc of fpFunc: begin
    aSL.add('  result := getDefault;');
    aSL.add('  case assigned(FOFunc' + aDefs[i].suffix + ') of TRUE: EXIT(FOFunc' + aDefs[i].suffix + '(' + aDefs[i].paramList+ ')); end;');
    aSL.add('  case assigned(FSFunc' + aDefs[i].suffix + ') of TRUE: EXIT(FSFunc' + aDefs[i].suffix + '(' + aDefs[i].paramList + ')); end;');
    aSL.add('  case assigned(FAFunc' + aDefs[i].suffix + ') of TRUE: EXIT(FAFunc' + aDefs[i].suffix + '(' + aDefs[i].paramList + ')); end;'); end;end;
    case aFuncProc of fpProc: begin
    aSL.add('  case assigned(FOProc' + aDefs[i].suffix + ') of TRUE: FOProc' + aDefs[i].suffix + '(' + aDefs[i].paramList+ '); end;');
    aSL.add('  case assigned(FSProc' + aDefs[i].suffix + ') of TRUE: FSProc' + aDefs[i].suffix + '(' + aDefs[i].paramList + '); end;');
    aSL.add('  case assigned(FAProc' + aDefs[i].suffix + ') of TRUE: FAProc' + aDefs[i].suffix + '(' + aDefs[i].paramList + '); end;'); end;end;
    aSL.add('end;');
    aSL.add('');
  end;
end;

procedure writeAndThens(const aDefs: TDefs; const aSL: TStringList; const aFuncProc: TFuncProc);
begin
  case aFuncProc of fpFunc:
  for var i := 0 to high(aDefs) do begin
    var vTOTSTA := 'TO';
    for var j := 1 to 3 do begin
      aSL.add('');
      aSL.add(format('function TAction<TResult>.andThen(const aGuardClause: boolean; const aTrueFunc: %sFunc%s<TResult>; %s): IAction<TResult>;', [vTOTSTA, aDefs[i].suffix, aDefs[i].paramDefs]));
      aSL.add('var');
      aSL.add('  vResult: TResult;');
      aSL.add('  bResult: boolean absolute vResult;');
      aSL.add('begin');
      aSL.add('  case success and aGuardClause of TRUE: begin');
      aSL.add(format('                                            vResult := aTrueFunc(%s);', [aDefs[i].paramList]));
      aSL.add('                                            success := bResult; end;end;');
      aSL.add('  result := SELF;');
      aSL.add('end;');
      case vTOTSTA = 'TS' of TRUE: vTOTSTA := 'TA'; end;
      case vTOTSTA = 'TO' of TRUE: vTOTSTA := 'TS'; end;
    end;end;end;

  case aFuncProc of fpFunc:
  for var i := 0 to high(aDefs) do begin
    var vTOTSTA := 'TO';
    for var j := 1 to 3 do begin
      aSL.add('');
      aSL.add(format('function TAction<TResult>.aside(const aGuardClause: boolean; const aTrueFunc: %sFunc%s<TResult>; %s): IAction<TResult>;', [vTOTSTA, aDefs[i].suffix, aDefs[i].paramDefs]));
      aSL.add('begin');
      aSL.add(format('  case success and aGuardClause of TRUE: aTrueFunc(%s); end;', [aDefs[i].paramList]));
      aSL.add('  result := SELF;');
      aSL.add('end;');
      case vTOTSTA = 'TS' of TRUE: vTOTSTA := 'TA'; end;
      case vTOTSTA = 'TO' of TRUE: vTOTSTA := 'TS'; end;
    end;end;end;

  case (aFuncProc = fpFunc) and (vUnit = BAZ_ACTION_UNIT) of TRUE: begin
    aSL.add('');
    aSL.add('function TAction<TResult>.getSuccess: boolean;');
    aSL.add('begin');
    aSL.add('  result := FSuccess;');
    aSL.add('end;');

    aSL.add('');
    aSL.add('procedure TAction<TResult>.setSuccess(const aValue: boolean);');
    aSL.add('begin');
    aSL.add('  FSuccess := aValue;');
    aSL.add('end;');

    aSL.add('');
    aSL.add('class function TAction<TResult>.startWith(const aBoolean: boolean): IAction<TResult>;');
    aSL.add('begin');
    aSL.add('  result             := TAction<TResult>.Create(NIL);');
    aSL.add('  result.success     := aBoolean;');
    aSL.add('end;');

    aSL.add('');
    aSL.add('class function TAction<TResult>.startWithNot(const aBoolean: boolean): IAction<TResult>;');
    aSL.add('begin');
    aSL.add('  result             := TAction<TResult>.Create(NIL);');
    aSL.add('  result.success     := NOT aBoolean;');
    aSL.add('end;');

    aSL.add('');
    aSL.add('function TAction<TResult>.thenStop: boolean;');
    aSL.add('begin');
    aSL.add('  result := FSuccess;');
    aSL.add('end;');
  end;end;
end;

function copySection(const aHeader: string; const aFilePath: string; const aSL: TStringList): TVoid;
begin
  var vInput := TStringList.create;
  try
    vInput.loadFromFile(aFilePath);
    var vCopying: boolean := FALSE;

    for var vLine: string in vInput do
    begin
      case (aHeader = '') and (vLine.startsWith(':')) of TRUE:  begin
                                                                  vUnit := copy(vLine, 2, maxInt);
                                                                  case aSL = NIL of FALSE: aSL.add(format('unit %s;', [vUnit])); end;
                                                                  BREAK; end;end;

      vCopying := vCopying and NOT vLine.startsWith('#');

      case vCopying of TRUE: aSL.add(vLine); end;

      vCopying := vCopying or (vLine = aHeader);
    end;

  finally
    vInput.free;
  end;
end;

procedure writeUnit(const aDefs: TDefs; const aFilePathIn: string);
begin
  var vSL := TStringList.Create;
  try

// "unit" and "uses"
    copySection('#' + vUnit + ' copyright', aFilePathIn, vSL);
    copySection('',  aFilePathIn, vSL); // obtain vUnit and write out the unit name
    writeUnitHeader(vSL);
    copySection('#' + vUnit + ' uses',  aFilePathIn, vSL);

// Function and Procedure Types
    writeTypes(aDefs, vSL, fpFunc);
    writeTypes(aDefs, vSL, fpProc);

// interface and class definitions functions
    writeInterface            (aDefs, vSL, fpFunc); // interface definition, not the interface section header
    writeClassHeader          (aDefs, vSL, fpFunc);
    writeClassMembers         (aDefs, vSL, fpFunc);
    writeClassConstructors    (aDefs, vSL, fpFunc);
    writeClassPicks           (aDefs, vSL, fpFunc);
    writeClassPerforms        (aDefs, vSL, fpFunc);

// interface and class definitions procedures
    writeInterface            (aDefs, vSL, fpProc); // interface definition, not the interface section header
    writeClassHeader          (aDefs, vSL, fpProc);
    writeClassMembers         (aDefs, vSL, fpProc);
    writeClassConstructors    (aDefs, vSL, fpProc);
    writeClassPicks           (aDefs, vSL, fpProc);
    writeClassPerforms        (aDefs, vSL, fpProc);

// implementation section functions
    writeImplementationHeader (       vSL, fpFunc);
    writeConstructorsFixed    (aDefs, vSL, fpFunc);
    writeConstructors         (aDefs, vSL, fpFunc);
    writePicksTrueFunc        (aDefs, vSL, fpFunc);
    writePicksTrueFalseFunc   (aDefs, vSL, fpFunc);
    writePerforms             (aDefs, vSL, fpFunc);
    writeAndThens             (aDefs, vSL, fpFunc);

// implementation section procedures
//    writeImplementationHeader (       vSL, fpProc);
    writeConstructorsFixed    (aDefs, vSL, fpProc);
    writeConstructors         (aDefs, vSL, fpProc);
    writePicksTrueFunc        (aDefs, vSL, fpProc);
    writePicksTrueFalseFunc   (aDefs, vSL, fpProc);
    writePerforms             (aDefs, vSL, fpProc);

    vSL.add('end.');

    for var i := 0 to vSL.count - 1 do
      vSL[i] := stringReplace(vSL[i], '; )', ')', []);

    vSL.saveToFile(vUnit + '.pas');
  finally
    vSL.Free;
  end;
end;

function getNames(const aDataTypes: TArray<string>): TArray<string>;
begin
  result      := copy(aDataTypes);
  var vTotals := TDictionary<string, integer>.create;
  var vCounts := TDictionary<string, integer>.create;

  try

    for var vType in aDataTypes do vTotals.addOrSetValue(vType, 0);
    for var vType in aDataTypes do vCounts.addOrSetValue(vType, 0);

    for var vType in aDataTypes do vTotals.addOrSetValue(vType, vTotals.items[vType] + 1);

    for var i := low(result) to high(result) do
    begin
      var vType := result[i];
      vCounts.addOrSetValue(vType, vCounts.items[vType] + 1);

      case vTotals.items[vType] > 1 of TRUE: result[i] := vType + vCounts.items[vType].toString; end;
    end;

  finally
    vCounts.free;
    vTotals.free;
  end;
end;

procedure readDefs(var aDefs: TDefs; const aFilePath: string);
begin
  var vLines := TStringList.Create;
  try
    vLines.loadFromFile(aFilePath);

    var vStartIx  := vLines.indexOf('#' + vUnit + ' types') + 1;
    var vEndIx    := vLines.count - 1;
    for var i := vStartIx to vLines.count - 1 do begin
      case vLines[i].startsWith('#') of TRUE: begin
                                                vEndIx := i - 1;
                                                BREAK; end;end;
    end;
    setLength(aDefs, vEndIx - vStartIx);

    var vDefIx := -1;

    for var i := vStartIx to vEndIx do
    begin
      var vLine := trim(vLines[i]);

      // data validity checks
      var vLineParts := vLine.split([':'], TStringSplitOptions.ExcludeEmpty); // for a no-params suffix, the terminating colon in optional
      case length(vLineParts) = 0 of TRUE: CONTINUE; end;                     // line contains nothing

      // line contains at least a record type suffix in element [0]

      var vDataTypes: TArray<string>;                                         // if datatypes are included, the record type suffix must be terminated by a colon
      case length(vLineParts) > 1 of TRUE: vDataTypes := vLineParts[1].split([' '], TStringSplitOptions.ExcludeEmpty); end; // datatypes must be separated with a space

      var vNames := getNames(vDataTypes);

      // data accepted
      inc(vDefIx);

      aDefs[vDefIx].suffix := vLineParts[0];

      var vParamDefs := '';
      var vParamList := '';
      var vSemiColon := '';
      var vComma     := '';

      for var j := 0 to length(vDataTypes) - 1 do
      begin
        vParamDefs := vParamDefs + format('%sconst a%s: %s', [vSemiColon, upperCase(vNames[j][1]) + copy(vNames[j], 2, maxInt), vDataTypes[j]]);
        vParamList := vParamList + format('%sa%s', [vComma, upperCase(vNames[j][1]) + copy(vNames[j], 2, maxInt)]);
        vSemiColon := '; ';
        vComma     := ', ';
      end;

      aDefs[vDefIx].paramDefs := vParamDefs;
      aDefs[vDefIx].paramList := vParamList;
    end;

    setLength(aDefs, vDefIx + 1); // readjust for over-allocation in the event of rejected lines
  finally
    vLines.free;
  end;
end;

function test(const aString: string; const aBoolean: boolean): boolean;
begin
  writeln(aString + ' from mmpAction');
end;

procedure testReadDefs(const aFilePath: string);
var
  vDefs: TDefs;
begin
  readDefs(vDefs, aFilePath);

  for var i := 0 to length(vDefs) - 1 do
  begin
    writeln('Suffix: ', vDefs[i].suffix);
    writeln('Params: ', vDefs[i].paramDefs);
    writeln('----------------------');
  end;
end;

function soTrue: boolean;
begin
  result := TRUE;
end;

function sayItsTrue: boolean;
begin
  writeLn('It''s twoo! It''s twoo!');
  result := TRUE;
end;

function whisperSweetNothings: boolean;
begin
  writeLn('Wut?');
  result := FALSE;
end;

begin
  try
    // testReadDefs('bazActionDefs.txt');

    copySection('', FILE_PATH_IN, NIL); // obtain vUnit only

    readDefs  (vDefs, FILE_PATH_IN);
    writeUnit (vDefs, FILE_PATH_IN);

    //var vResult := TAction<boolean>.pick(TRUE, test).perform('hello', TRUE);

//    var result := TAction<boolean>.startWith(TRUE)
//                    .ensure(TRUE)
//                    .andThen(TRUE, function:boolean begin writeln('first andThen'); result := TRUE; end)
//                    .andThen(TRUE, function:boolean begin writeln('second andThen'); result := TRUE; end)
//                    .aside(TRUE, whisperSweetNothings)
//                    .andthen(TRUE, sayItsTrue)
//                    .andThen(TRUE, soTrue)
//                    .thenStop;
//
//    case result of   TRUE: writeln('TWOO...I mean, TRUE');
//                    FALSE: writeln('FALSE'); end;

//    var vTestParts := 'LoadsASpaces:  boolean  string           '.split([' ']);
//    var vTestParts := 'StringInteger: string integer'.split([':']);
//    var vTestParts := 'Boolean: boolean'.split([':'], TStringSplitOptions.ExcludeEmpty);
//    var vTestParts := ' boolean'.split([' '], TStringSplitOptions.ExcludeEmpty);
//    var vTestParts := 'NoParam:'.split([':'], TStringSplitOptions.ExcludeEmpty);
//    var vTestParts := 'NoParam'.split([':'], TStringSplitOptions.ExcludeEmpty);
//    writeLn(intToStr(length(vTestParts)));
//    writeLn(vTestParts[0]);
//    writeLn('>' + vTestParts[1] + '<');
  except
    on E: Exception do
      Writeln(E.ClassName, ': ', E.Message);
  end;
end.
