program bazActionGen;

{   bazActionGen
    Copyright (C) 2021-2099 Baz Cuda
    https://github.com/BazzaCuda/bazActionGen

    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307, USA
}

{$APPTYPE CONSOLE}

{$R *.res}

uses
  system.classes,
  system.generics.collections,
  system.sysUtils,
  vcl.dialogs,
  bazAction in 'Win64\Debug\bazAction.pas',
  mmpAction in 'Win64\Debug\mmpAction.pas',
  bazRTL in '..\_MVVM\_bazLib\bazRTL.pas';

type
  TDef = record
    suffix: string;
    paramDefs: string;
    paramList: string;
  end;

  TDefs = array of TDef;

  TVoid = record end;

const
  BAZ_ACTION_UNIT   = 'bazAction';
  FILE_PATH_IN      = 'bazActionDefs.txt';
  FILE_PATH_OUT     = 'bazAction.pas';

var
  vDefs: TDefs;
  vUnit: string = '';

procedure writeUnitHeader(const aSL: TStringList);
begin
//  aSL.add('''
//{   bazLib / bazAction
//    Copyright (C) 2021-2099 Baz Cuda
//    https://github.com/BazzaCuda/
//
//    This program is free software; you can redistribute it and/or modify
//    it under the terms of the GNU General Public License as published by
//    the Free Software Foundation; either version 3 of the License, or
//    (at your option) any later version.
//
//    This program is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//    GNU General Public License for more details.
//
//    You should have received a copy of the GNU General Public License
//    along with this program; if not, write to the Free Software
//    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307, USA
//
//''' + '}');
//  aSL.add('unit bazAction;');

  aSL.add('');
  aSL.add('interface');
  aSL.add('');
  aSL.add('{ THIS UNIT IS GENERATED BY bazActionGen.exe. AMEND THE bazActionDefs.txt FILE TO REGENERATE THIS UNIT FOR DIFFERENT FUNCTION TYPES AND FUNCTION SIGNATURES }');
  case vUnit = BAZ_ACTION_UNIT of  TRUE: aSL.add('{ Add project-specific datatypes to IAction and TAction descendants in a separate unit }');
                                  FALSE: aSL.add('{ These are project-specific datatypes added via identically-named descendants of bazAction.IAction and bazAction.TAction }'); end;
  aSL.add('');
end;

procedure writeTypes(const aDefs: TDefs; const aSL: TStringList);
const
  WIDTH_SUFFIX = 20;
  WIDTH_PARAMS = 80;
begin
  aSL.add('type');
  case vUnit = BAZ_ACTION_UNIT of  TRUE: aSL.add('  TVoid = record end;');
                                  FALSE: aSL.add('  TVoid = bazAction.TVoid;'); end;
  aSL.add('');

  var vFuncPrefix := '';

  for var i := 0 to length(aDefs) - 1 do begin
    vFuncPrefix := 'function(' + aDefs[i].paramDefs + '):';
    aSL.add(format('  TOFunc%-*s<TResult> = %-*sTResult of object; // method of class instance', [WIDTH_SUFFIX, aDefs[i].suffix, WIDTH_PARAMS, vFuncPrefix]));

    vFuncPrefix := 'function(' + aDefs[i].paramDefs + '):';
    aSL.add(format('  TSFunc%-*s<TResult> = %-*sTResult;           // static method - no class instance', [WIDTH_SUFFIX, aDefs[i].suffix, WIDTH_PARAMS, vFuncPrefix]));

    vFuncPrefix := 'reference to function(' + aDefs[i].paramDefs + '):';
    aSL.add(format('  TAFunc%-*s<TResult> = %-*sTResult;           // anonymous method', [WIDTH_SUFFIX, aDefs[i].suffix, WIDTH_PARAMS, vFuncPrefix]));

    aSL.add('');
  end;
end;

procedure writeInterface(const aDefs: TDefs; const aSL: TStringList);
const
  WIDTH_PARAMS = 70;
begin
  case vUnit = BAZ_ACTION_UNIT of  TRUE: aSL.add('  IAction<TResult> = interface');
                                  FALSE: aSL.add('  IAction<TResult> = interface(bazAction.IAction<TResult>)'); end;

  aSL.add('    function default(const aValue: TResult): IAction<TResult>; // the fallback value');
  aSL.add('');

  for var i := 0 to length(aDefs) - 1 do
    aSL.add(format('    function perform(%-*sTResult; overload;', [WIDTH_PARAMS, aDefs[i].paramDefs + '):']));

  aSL.add('');
  aSL.add('    function getAssigned: boolean;');
  aSL.add('    property assigned:    boolean read getAssigned;');
  aSL.add('  end;');
  aSL.add('');
end;

procedure writeClassHeader(const aDefs: TDefs; const aSL: TStringList);
begin
  case vUnit = BAZ_ACTION_UNIT of  TRUE: aSL.add('  TAction<TResult> = class(TInterfacedObject, IAction<TResult>)');
                                  FALSE: aSL.add('  TAction<TResult> = class(bazAction.TAction<TResult>, bazAction.IAction<TResult>)'); end;
end;

procedure writeClassMembers(const aDefs: TDefs; const aSL: TStringList);
const
  WIDTH_SUFFIX = 30;
begin
  aSL.add('  strict private');
  aSL.add('    FFuncAssigned: boolean;');
  aSL.add('    FDefault:      TResult; // initialised in constructor, used in perform');
  aSL.add('');

  for var i := 0 to high(aDefs) do
  begin
    aSL.add(format('    FOFunc%-*sTOFunc%-*s <TResult>;', [WIDTH_SUFFIX, aDefs[i].suffix + ':', WIDTH_SUFFIX, aDefs[i].suffix]));
    aSL.add(format('    FSFunc%-*sTAFunc%-*s <TResult>;', [WIDTH_SUFFIX, aDefs[i].suffix + ':', WIDTH_SUFFIX, aDefs[i].suffix]));
    aSL.add(format('    FAFunc%-*sTAFunc%-*s <TResult>;', [WIDTH_SUFFIX, aDefs[i].suffix + ':', WIDTH_SUFFIX, aDefs[i].suffix]));
    aSL.add('');
  end;
end;

procedure writeClassConstructors(const aDefs: TDefs; const aSL: TStringList);
const
  WIDTH_PARAM_NAME  = 30;
  WIDTH_FUNC_TYPE   = 25;
  WIDTH_GENERIC     = 1;
begin
  aSL.add('    constructor Create;                           overload;');
  aSL.add('    constructor Create(const aFuncNIL: pointer);  overload;');
  aSL.add('');


  for var i := 0 to high(aDefs) do
  begin
    aSL.add(format('    constructor Create(%-*s%-*s%-*s);     overload;', [WIDTH_PARAM_NAME, 'const aFunc' + aDefs[i].suffix + ':', WIDTH_FUNC_TYPE, 'TOFunc' + aDefs[i].suffix, WIDTH_GENERIC, '<TResult>']));
    aSL.add(format('    constructor Create(%-*s%-*s%-*s);     overload;', [WIDTH_PARAM_NAME, 'const aFunc' + aDefs[i].suffix + ':', WIDTH_FUNC_TYPE, 'TSFunc' + aDefs[i].suffix, WIDTH_GENERIC, '<TResult>']));
    aSL.add(format('    constructor Create(%-*s%-*s%-*s);     overload;', [WIDTH_PARAM_NAME, 'const aFunc' + aDefs[i].suffix + ':', WIDTH_FUNC_TYPE, 'TAFunc' + aDefs[i].suffix, WIDTH_GENERIC, '<TResult>']));
    aSL.add('');
  end;
end;

procedure writeClassPicks(const aDefs: TDefs; const aSL: TStringList);
const
  WIDTH_PARAM_NAME  = 60;
  WIDTH_FUNC_TYPE   = 25;
begin
  aSL.add('  public');
  aSL.add('    function getAssigned: boolean;');
  aSL.add('    function default(const aValue: TResult): IAction<TResult>;');
  aSL.add('');

  for var i := 0 to high(aDefs) do
  begin
    aSL.add(format('    class function pick(%-*s%-*s<TResult>):           IAction<TResult>; overload;', [WIDTH_PARAM_NAME, 'const aBoolean: boolean; const aTrueFunc' + aDefs[i].suffix + ':', WIDTH_FUNC_TYPE, 'TOFunc' + aDefs[i].suffix]));
    aSL.add(format('    class function pick(%-*s%-*s<TResult>):           IAction<TResult>; overload;', [WIDTH_PARAM_NAME, 'const aBoolean: boolean; const aTrueFunc' + aDefs[i].suffix + ':', WIDTH_FUNC_TYPE, 'TSFunc' + aDefs[i].suffix]));
    aSL.add(format('    class function pick(%-*s%-*s<TResult>):           IAction<TResult>; overload;', [WIDTH_PARAM_NAME, 'const aBoolean: boolean; const aTrueFunc' + aDefs[i].suffix + ':', WIDTH_FUNC_TYPE, 'TAFunc' + aDefs[i].suffix]));
    aSL.add('');
  end;
end;

procedure writeClassPerforms(const aDefs: TDefs; const aSL: TStringList);
const
  WIDTH_PARAMs  = 60;
begin
  for var i := 0 to high(aDefs) do
    aSL.add(format('    function perform(%-*sTResult; overload;', [WIDTH_PARAMS, aDefs[i].paramDefs + '):']));

  aSL.add('  end;');
  aSL.add('');
end;

procedure writeImplementationHeader(const aSL: TStringList);
begin
  aSL.add('implementation');
  aSL.add('');
  aSL.add('uses');
  aSL.add('  bazRTL;');
  aSL.add('');
  aSL.add('{ TAction<TResult> }');
  aSL.add('');
end;

procedure writeConstructorsFixed(aDefs: TDefs; const aSL: TStringList);
begin
  aSL.add('constructor TAction<TResult>.Create;');
  aSL.add('begin');
  aSL.add('  raise exception.create(''Don''''t call TAction.create'');');
  aSL.add('end;');
  aSL.add('');

  aSL.add('constructor TAction<TResult>.Create(const aFuncNIL: pointer);');
  aSL.add('begin');
  aSL.add('  case aFuncNIL = NIL of   TRUE: EXIT;');
  aSL.add('                          FALSE: raise exception.Create(''Functionless constructor must be called with NIL''); end;');
  aSL.add('end;');
  aSL.add('');
end;

procedure writeConstructorsOld(aDefs: TDefs; const aSL: TStringList);
const
  WIDTH_PARAM_NAME  = 16;
  WIDTH_FUNC_TYPE   = 10;
begin

    for var i := 0 to high(aDefs) do
  begin
    aSL.add(format('constructor TAction<TResult>.Create(%-*s%-*s<TResult>);', [WIDTH_PARAM_NAME, 'const aFunc' + aDefs[i].suffix + ':', WIDTH_FUNC_TYPE, 'TOFunc' + aDefs[i].suffix]));
    aSL.add('begin');
    aSL.add(format('  FOFunc%s  := aFunc%s;', [aDefs[i].suffix, aDefs[i].suffix]));
    aSL.add('  FFuncAssigned := assigned(aFunc' + aDefs[i].suffix + ');');
    aSL.add('end;');
    aSL.add('');

    aSL.add(format('constructor TAction<TResult>.Create(%-*s%-*s<TResult>);', [WIDTH_PARAM_NAME, 'const aFunc' + aDefs[i].suffix + ':', WIDTH_FUNC_TYPE, 'TSFunc' + aDefs[i].suffix]));
    aSL.add('begin');
    aSL.add(format('  FSFunc%s  := aFunc%s;', [aDefs[i].suffix, aDefs[i].suffix]));
    aSL.add('  FFuncAssigned := assigned(aFunc' + aDefs[i].suffix + ');');
    aSL.add('end;');
    aSL.add('');

    aSL.add(format('constructor TAction<TResult>.Create(%-*s%-*s<TResult>);', [WIDTH_PARAM_NAME, 'const aFunc' + aDefs[i].suffix + ':', WIDTH_FUNC_TYPE, 'TAFunc' + aDefs[i].suffix]));
    aSL.add('begin');
    aSL.add(format('  FAFunc%s  := aFunc%s;', [aDefs[i].suffix, aDefs[i].suffix]));
    aSL.add('  FFuncAssigned := assigned(aFunc' + aDefs[i].suffix + ');');
    aSL.add('end;');
    aSL.add('');
  end;
end;

procedure writeConstructors(const aDefs: TDefs; const aSL: TStringList);
const
  WIDTH_PARAM_NAME  = 16;
  WIDTH_FUNC_TYPE   = 10;
  WIDTH_FIELD_NAME  = 20;
begin
  for var i := 0 to high(aDefs) do
  begin
    aSL.add(format('constructor TAction<TResult>.Create(const aFunc%s: TOFunc%s<TResult>);', [aDefs[i].suffix, aDefs[i].suffix]));
    aSL.add('begin');
    aSL.add(format('  %-*s := aFunc%s;', [WIDTH_FIELD_NAME, 'FOFunc' + aDefs[i].suffix, aDefs[i].suffix]));
    aSL.add(format('  %-*s := assigned(aFunc%s);', [WIDTH_FIELD_NAME, 'FFuncAssigned', aDefs[i].suffix]));
    aSL.add('end;');
    aSL.add('');

    aSL.add(format('constructor TAction<TResult>.Create(const aFunc%s: TSFunc%s<TResult>);', [aDefs[i].suffix, aDefs[i].suffix]));
    aSL.add('begin');
    aSL.add(format('  %-*s := aFunc%s;', [WIDTH_FIELD_NAME, 'FSFunc' + aDefs[i].suffix, aDefs[i].suffix]));
    aSL.add(format('  %-*s := assigned(aFunc%s);', [WIDTH_FIELD_NAME, 'FFuncAssigned', aDefs[i].suffix]));
    aSL.add('end;');
    aSL.add('');

    aSL.add(format('constructor TAction<TResult>.Create(const aFunc%s: TAFunc%s<TResult>);', [aDefs[i].suffix, aDefs[i].suffix]));
    aSL.add('begin');
    aSL.add(format('  %-*s := aFunc%s;', [WIDTH_FIELD_NAME, 'FAFunc' + aDefs[i].suffix, aDefs[i].suffix]));
    aSL.add(format('  %-*s := assigned(aFunc%s);', [WIDTH_FIELD_NAME, 'FFuncAssigned', aDefs[i].suffix]));
    aSL.add('end;');
    aSL.add('');
  end;
end;

procedure writePicks(const aDefs: TDefs; const aSL: TStringList);
begin
  for var i := 0 to high(aDefs) do
  begin
    aSL.add(format('class function TAction<TResult>.pick(const aBoolean: boolean; const aTrueFunc%s: TOFunc%s<TResult>): IAction<TResult>;', [aDefs[i].suffix, aDefs[i].suffix]));
    aSL.add('begin');
    aSL.add('  case aBoolean of');

    var vPointerPrefix: string := '';
    var vPointerSuffix: string := '';
    case vUnit = BAZ_ACTION_UNIT of FALSE: vPointerPrefix := 'IAction<TResult>(pointer('; end;
    case vUnit = BAZ_ACTION_UNIT of FALSE: vPointerSuffix := '))'; end;

    aSL.add(format('     TRUE:  result := %sTAction<TResult>.Create(aTrueFunc%s)%s;', [vPointerPrefix, aDefs[i].suffix, vPointerSuffix]));
    aSL.add(format('    FALSE:  result := %sTAction<TResult>.Create(NIL)%s;', [vPointerPrefix, vPointerSuffix]));
    aSL.add('  end;');
    aSL.add('end;');
    aSL.add('');

    aSL.add(format('class function TAction<TResult>.pick(const aBoolean: boolean; const aTrueFunc%s: TSFunc%s<TResult>): IAction<TResult>;', [aDefs[i].suffix, aDefs[i].suffix]));
    aSL.add('begin');
    aSL.add('  case aBoolean of');
    aSL.add(format('     TRUE:  result := %sTAction<TResult>.Create(aTrueFunc%s)%s;', [vPointerPrefix, aDefs[i].suffix, vPointerSuffix]));
    aSL.add(format('    FALSE:  result := %sTAction<TResult>.Create(NIL)%s;', [vPointerPrefix, vPointerSuffix]));
    aSL.add('  end;');
    aSL.add('end;');
    aSL.add('');

    aSL.add(format('class function TAction<TResult>.pick(const aBoolean: boolean; const aTrueFunc%s: TAFunc%s<TResult>): IAction<TResult>;', [aDefs[i].suffix, aDefs[i].suffix]));
    aSL.add('begin');
    aSL.add('  case aBoolean of');
    aSL.add(format('     TRUE:  result := %sTAction<TResult>.Create(aTrueFunc%s)%s;', [vPointerPrefix, aDefs[i].suffix, vPointerSuffix]));
    aSL.add(format('    FALSE:  result := %sTAction<TResult>.Create(NIL)%s;', [vPointerPrefix, vPointerSuffix]));
    aSL.add('  end;');
    aSL.add('end;');
    aSL.add('');
  end;
end;

procedure writePerforms(const aDefs: TDefs; const aSL: TStringList);
begin
  aSL.add('function TAction<TResult>.getAssigned: boolean;');
  aSL.add('begin');
  aSL.add('  result := FFuncAssigned;');
  aSL.add('end;');
  aSL.add('');

  var vPointerPrefix: string := '';
  var vPointerSuffix: string := '';
  case vUnit = BAZ_ACTION_UNIT of FALSE: vPointerPrefix := 'IAction<TResult>(pointer('; end;
  case vUnit = BAZ_ACTION_UNIT of FALSE: vPointerSuffix := '))'; end;

  aSL.add('function TAction<TResult>.default(const aValue: TResult): IAction<TResult>;');
  aSL.add('begin');
  aSL.add('  FDefault := aValue;');
  aSL.add(format('  result   := %sSELF%s;', [vPointerPrefix, vPointerSuffix]));
  aSL.add('end;');
  aSL.add('');

  for var i := 0 to high(aDefs) do
  begin
    aSL.add('function TAction<TResult>.perform(' + aDefs[i].paramDefs + '): TResult;');
    aSL.add('begin');
    aSL.add('  result := FDefault;');
    aSL.add('  case assigned(FOFunc' + aDefs[i].suffix + ') of TRUE: EXIT(FOFunc' + aDefs[i].suffix + '(' + aDefs[i].paramList+ ')); end;');
    aSL.add('  case assigned(FSFunc' + aDefs[i].suffix + ') of TRUE: EXIT(FSFunc' + aDefs[i].suffix + '(' + aDefs[i].paramList + ')); end;');
    aSL.add('  case assigned(FAFunc' + aDefs[i].suffix + ') of TRUE: EXIT(FAFunc' + aDefs[i].suffix + '(' + aDefs[i].paramList + ')); end;');
    aSL.add('end;');
    aSL.add('');
  end;

  aSL.add('end.');
end;

function copySection(const aHeader: string; const aFilePath: string; const aSL: TStringList): TVoid;
begin
  var vInput := TStringList.create;
  try
    vInput.loadFromFile(aFilePath);
    var vCopying: boolean := FALSE;

    for var vLine: string in vInput do
    begin
      case (aHeader = '') and (vLine.startsWith(':')) of TRUE:  begin
                                                                  vUnit := copy(vLine, 2, maxInt);
                                                                  aSL.add(format('unit %s;', [vUnit]));
                                                                  BREAK; end;end;

      vCopying := vCopying and NOT vLine.startsWith('#');

      case vCopying of TRUE: aSL.add(vLine); end;

      vCopying := vCopying or (vLine = aHeader);
    end;

  finally
    vInput.free;
  end;
end;

procedure writeUnit(const aDefs: TDefs; const aFilePathIn: string);
begin
  var vSL := TStringList.Create;
  try
    copySection('#copyright', aFilePathIn, vSL);
    copySection('',  aFilePathIn, vSL); // obtains vUnit and writes out the unit name
    writeUnitHeader(vSL);
    copySection('#uses',  aFilePathIn, vSL);
    writeTypes(aDefs, vSL);
    writeInterface(aDefs, vSL); // interface definition, not the interface section header
    writeClassHeader(aDefs, vSL);
    writeClassMembers(aDefs, vSL);
    writeClassConstructors(aDefs, vSL);
    writeClassPicks(aDefs, vSL);
    writeClassPerforms(aDefs, vSL);
    writeImplementationHeader(vSL);
    writeConstructorsFixed(aDefs, vSL);
    writeConstructors(aDefs, vSL);
    writePicks(aDefs, vSL);;
    writePerforms(aDefs, vSL);
    vSL.saveToFile(vUnit + '.pas');
  finally
    vSL.Free;
  end;
end;

function getNames(const aDataTypes: TArray<string>): TArray<string>;
begin
  result      := copy(aDataTypes);
  var vTotals := TDictionary<string, integer>.create;
  var vCounts := TDictionary<string, integer>.create;

  try

    for var vType in aDataTypes do vTotals.addOrSetValue(vType, 0);
    for var vType in aDataTypes do vCounts.addOrSetValue(vType, 0);

    for var vType in aDataTypes do vTotals.addOrSetValue(vType, vTotals.items[vType] + 1);

    for var i := low(result) to high(result) do
    begin
      var vType := result[i];
      vCounts.addOrSetValue(vType, vCounts.items[vType] + 1);

      case vTotals.items[vType] > 1 of TRUE: result[i] := vType + vCounts.items[vType].toString; end;
    end;

  finally
    vCounts.free;
    vTotals.free;
  end;
end;

procedure readDefs(var aDefs: TDefs; const aFilePath: string);
begin
  var vLines := TStringList.Create;
  try
    vLines.loadFromFile(aFilePath);

    var vStartIx := vLines.indexOf('#types') + 1;
    setLength(aDefs, vLines.count - vStartIx);

    var vDefIx := -1;

    for var i := vStartIx to vLines.count - 1 do
    begin
      var vLine := trim(vLines[i]);

      // data validity checks
      var vLineParts := vLine.split([':'], TStringSplitOptions.ExcludeEmpty); // for a no-params suffix, the terminating colon in optional
      case length(vLineParts) = 0 of TRUE: CONTINUE; end;                     // line contains nothing

      // line contains at least a record type suffix in element [0]

      var vDataTypes: TArray<string>;                                         // if datatypes are included, the record type suffix must be terminated by a colon
      case length(vLineParts) > 1 of TRUE: vDataTypes := vLineParts[1].split([' '], TStringSplitOptions.ExcludeEmpty); end; // datatypes must be separated with a space

      var vNames := getNames(vDataTypes);

      // data accepted
      inc(vDefIx);

      aDefs[vDefIx].suffix := vLineParts[0];

      var vParamDefs := '';
      var vParamList := '';
      var vSemiColon := '';
      var vComma     := '';

      for var j := 0 to length(vDataTypes) - 1 do
      begin
        vParamDefs := vParamDefs + format('%sconst a%s: %s', [vSemiColon, upperCase(vNames[j][1]) + copy(vNames[j], 2, maxInt), vDataTypes[j]]);
        vParamList := vParamList + format('%sa%s', [vComma, upperCase(vNames[j][1]) + copy(vNames[j], 2, maxInt)]);
        vSemiColon := '; ';
        vComma     := ', ';
      end;

      aDefs[vDefIx].paramDefs := vParamDefs;
      aDefs[vDefIx].paramList := vParamList;
    end;

    setLength(aDefs, vDefIx + 1); // readjust for over-allocation in the event of rejected lines
  finally
    vLines.free;
  end;
end;

function test(const aString: string; const aBoolean: boolean): boolean;
begin
  writeln(aString + ' from mmpAction');
end;

procedure testReadDefs(const aFilePath: string);
var
  vDefs: TDefs;
begin
  readDefs(vDefs, aFilePath);

  for var i := 0 to length(vDefs) - 1 do
  begin
    writeln('Suffix: ', vDefs[i].suffix);
    writeln('Params: ', vDefs[i].paramDefs);
    writeln('----------------------');
  end;
end;

begin
  try
    // testReadDefs('bazActionDefs.txt');

    readDefs  (vDefs, FILE_PATH_IN);
    writeUnit (vDefs, FILE_PATH_IN);

    var vResult := TAction<boolean>.pick(TRUE, test).perform('hello', TRUE);

//    var vTestParts := 'LoadsASpaces:  boolean  string           '.split([' ']);
//    var vTestParts := 'StringInteger: string integer'.split([':']);
//    var vTestParts := 'Boolean: boolean'.split([':'], TStringSplitOptions.ExcludeEmpty);
//    var vTestParts := ' boolean'.split([' '], TStringSplitOptions.ExcludeEmpty);
//    var vTestParts := 'NoParam:'.split([':'], TStringSplitOptions.ExcludeEmpty);
//    var vTestParts := 'NoParam'.split([':'], TStringSplitOptions.ExcludeEmpty);
//    writeLn(intToStr(length(vTestParts)));
//    writeLn(vTestParts[0]);
//    writeLn('>' + vTestParts[1] + '<');
  except
    on E: Exception do
      Writeln(E.ClassName, ': ', E.Message);
  end;
end.
