program bazActionGen;

{   bazActionGen
    Copyright (C) 2021-2099 Baz Cuda
    https://github.com/BazzaCuda/bazActionGen

    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307, USA
}

{$APPTYPE CONSOLE}

{$R *.res}

uses
  system.classes,
  system.generics.collections,
  system.sysUtils,
  madExcept,
  madLinkDisAsm,
  madListHardware,
  madListProcesses,
  madListModules,
  bazAction in 'Win64\Debug\bazAction.pas',
  bazFuncDefs in 'Win64\Debug\bazFuncDefs.pas',
  mmpAction in 'Win64\Debug\mmpAction.pas',
  vcl.dialogs,
  _debugWindow in '_debugWindow\_debugWindow.pas',
  bazRTL in 'Win64\Debug\bazRTL.pas';

type
  TDef = record
    suffix: string;
    paramDefs: string;
    paramList: string;
  end;

  TDefs = array of TDef;

  TVoid = record end;

  TFuncProc = (fpFunc, fpProc);

const
  BAZ_ACTION_UNIT   = 'bazAction';
  FILE_PATH_IN      = 'bazActionDefs.txt';
  FILE_PATH_OUT     = 'bazAction.pas';

var
  vDefs: TDefs;
//  vUnit: string = '';

procedure writeUnitHeader(const vUnit: string; const aSL: TStringList);
begin
  aSL.add('');
  aSL.add('interface');
  aSL.add('');
  aSL.add('{ THIS UNIT IS GENERATED BY bazActionGen.exe. AMEND THE bazActionDefs.txt FILE TO REGENERATE THIS UNIT FOR DIFFERENT FUNCTION TYPES AND FUNCTION SIGNATURES }');
  case vUnit = BAZ_ACTION_UNIT of  TRUE: aSL.add('{ Add project-specific datatypes to TAction<>/TAction descendants in a separate unit }');
                                  FALSE: aSL.add('{ These are project-specific datatypes added via identically-named descendants of bazAction.TAction }'); end;
  aSL.add('');
end;

procedure writeType(const vUnit: string; const aDefs: TDefs; const aSL: TStringList; const aFuncProc: TFuncProc);
begin
  case aFuncProc of fpFunc: begin
                              aSL.add('type');
                              //case vUnit = BAZ_ACTION_UNIT of  TRUE: aSL.add('  TVoid = record end;');
                              //                                FALSE: aSL.add('  TVoid = bazAction.TVoid;'); end;
                              end;end;
end;

procedure writeTypes(const vUnit: string; const aDefs: TDefs; const aSL: TStringList; const aFuncProc: TFuncProc);
const
  WIDTH_SUFFIX = 20;
  WIDTH_PARAMS = 80;
begin
  var vFuncPrefix := '';

  var vResult1            := '';
  var vResult2            := '';
  var vFuncProc           := 'Proc';
  var vFunctionProcedure  := 'procedure';
  case aFuncProc of fpFunc: begin
                              vFunctionProcedure  := 'function';
                              vFuncProc           := 'Func';
                              vResult1            := '<TResult>';
                              vResult2            := 'TResult'; end;end;

  var vColon := '';
  case aFuncProc of fpFunc: vColon := ':'; end;

  aSL.add('');
  case (aFuncProc = fpFunc) and (vUnit = BAZ_ACTION_UNIT) of TRUE: aSL.add('  TFunc<T> = reference to function: T;'); end;

  for var i := 0 to length(aDefs) - 1 do begin

    vFuncPrefix := format('reference to %s(' + aDefs[i].paramDefs + ')%s', [vFunctionProcedure, vColon]);
    aSL.add(format('  TA%s%-*s%s = %-*s%s;', [vFuncProc, WIDTH_SUFFIX, aDefs[i].suffix, vResult1, WIDTH_PARAMS, vFuncPrefix, vResult2]));
  end;
end;

procedure writeClassHeader(const vUnit: string; const aDefs: TDefs; const aSL: TStringList; const aFuncProc: TFuncProc);
begin
  var vResult1            := '';
  case aFuncProc of fpFunc: vResult1 := '<TResult>'; end;

  aSL.add('');
  case vUnit = BAZ_ACTION_UNIT of  TRUE: aSL.add(format('  TAction%s = class', [vResult1, vResult1]));
                                  FALSE: aSL.add(format('  TAction%s = class(bazAction.TAction%s)', [vResult1, vResult1, vUnit, vResult1])); end;
end;

procedure writeClassMembers(const vUnit: string; const aDefs: TDefs; const aSL: TStringList; const aFuncProc: TFuncProc);
const
  WIDTH_SUFFIX = 30;
begin
  case                          (vUnit = BAZ_ACTION_UNIT) of TRUE:  begin
                                                                      aSL.add('  strict private');
                                                                      aSL.add('    FMethodAssigned: boolean;');
                                                                      case aFuncProc of fpFunc: begin
                                                                           aSL.add('    FSuccess:        boolean;');
                                                                           aSL.add('    FDefault:        TResult; // initialised by constructor, set by optional .default(), used in .perform()'); end;end;end;end;

  var vFuncProc := 'Proc';
  var vResult1  := '';
  case aFuncProc of fpFunc: begin
                              vFuncProc := 'Func';
                              vResult1  := '<TResult>';  end;end;

  aSL.add('');
  for var i := 0 to high(aDefs) do
  begin
    aSL.add(format('    FA%s%-*sTA%s%-*s %s;', [vFuncProc, WIDTH_SUFFIX, aDefs[i].suffix + ':', vFuncProc, WIDTH_SUFFIX, aDefs[i].suffix, vResult1]));
  end;
end;

procedure writeClassConstructors(const aDefs: TDefs; const aSL: TStringList; const aFuncProc: TFuncProc);
const
  WIDTH_PARAM_NAME  = 30;
  WIDTH_FUNC_TYPE   = 25;
  WIDTH_GENERIC     = 1;
begin
  var vFuncProc := 'Proc';
  case aFuncProc of fpFunc: vFuncProc := 'Func'; end;

  aSL.add('');
  aSL.add('    constructor Create;                           overload;');
  aSL.add(format('    constructor Create(const a%sNIL: pointer);  overload;', [vFuncProc]));

  case aFuncProc of fpFunc:
  for var i := 0 to high(aDefs) do
  begin
    aSL.add(format('    constructor Create(%-*s%-*s%-*s);     overload;', [WIDTH_PARAM_NAME, 'const aFunc' + aDefs[i].suffix + ':', WIDTH_FUNC_TYPE, 'TAFunc' + aDefs[i].suffix, WIDTH_GENERIC, '<TResult>']));
  end;end;

  case aFuncProc of fpProc:
  for var i := 0 to high(aDefs) do
  begin
    aSL.add(format('    constructor Create(%-*s%-*s%-*s);     overload;', [WIDTH_PARAM_NAME, 'const aProc' + aDefs[i].suffix + ':', WIDTH_FUNC_TYPE, 'TAProc' + aDefs[i].suffix, WIDTH_GENERIC, '']));
  end;end;
end;

procedure writeClassPicks(const vUnit: string; const aDefs: TDefs; const aSL: TStringList; const aFuncProc: TFuncProc);
const
  WIDTH_PARAM_NAME  = 1;
  WIDTH_FUNC_TYPE   = 70;
  WIDTH_OTHER       = 30;
begin
  var vResult1 := '';
  var vResult2 := '';
  case aFuncProc of fpFunc: begin
                              vResult1 := '<TResult>';
                              vResult2 := 'TResult'; end;end;

  case                          (vUnit = BAZ_ACTION_UNIT) of TRUE:  begin
                                                                      aSL.add('  protected');
                                                                      aSL.add('  public');
                                                                      aSL.add('    function  getMethodAssigned: boolean;');
                                                                      aSL.add('    procedure setMethodAssigned(const aValue: boolean);');
                                                                      case aFuncProc of fpFunc: begin
                                                                          aSL.add('    function  getSuccess:        boolean;');
                                                                          aSL.add('    procedure setSuccess(const aValue: boolean);');
                                                                          aSL.add('    function  default(const aValue: TResult): TAction<TResult>;');
                                                                          aSL.add('    function  getDefault: TResult;'); end;end;end;end;

  case (aFuncProc = fpFunc) and (vUnit = BAZ_ACTION_UNIT) of TRUE: aSL.add(format('    function  ensure(const aGuardClause: boolean): TAction%s;', [vResult1])); end;
  case (aFuncProc = fpFunc) and (vUnit = BAZ_ACTION_UNIT) of TRUE: aSL.add(format('    function  assign<T>(var aTarget: T; const aValue: T): TAction%s; overload;', [vResult1])); end;
  case (aFuncProc = fpFunc) and (vUnit = BAZ_ACTION_UNIT) of TRUE: aSL.add(format('    function  assign<T>(const aGuardClause: boolean; var aTarget: T; const aValue: T): TAction%s; overload;', [vResult1])); end;
  case (aFuncProc = fpFunc) and (vUnit = BAZ_ACTION_UNIT) of TRUE: aSL.add(format('    function  assignFrom<T>(var aTarget: T; const aValue: TFunc<T>): TAction<TResult>; overload;', [])); end;
  case (aFuncProc = fpFunc) and (vUnit = BAZ_ACTION_UNIT) of TRUE: aSL.add(format('    function  assignFrom<T>(const aGuardClause: boolean; var aTarget: T; const aValue: TFunc<T>): TAction<TResult>; overload;', [])); end;

  aSL.add('');

  case aFuncProc of fpFunc:
  for var i := 0 to high(aDefs) do
  begin
    aSL.add(format('    class function pick(%-s%-*s<TResult>): TAction<TResult>; overload;', ['const aBoolean: boolean; const aTrueFunc' + ': ', WIDTH_FUNC_TYPE, 'TAFunc' + aDefs[i].suffix]));
  end;end;

  aSL.add('');

  case aFuncProc of fpFunc:
  for var i := 0 to high(aDefs) do
  begin
    aSL.add(format('    class function pick(%-s%-*s<TResult>): TAction<TResult>; overload;', ['const aBoolean: boolean; const aTrueFunc' + ': ', WIDTH_FUNC_TYPE, 'TAFunc' + aDefs[i].suffix + '<TResult>; const aFalseFunc' + ': TAFunc' + aDefs[i].suffix]));
  end;end;

  case aFuncProc of fpProc:
  for var i := 0 to high(aDefs) do
  begin
    aSL.add(format('    class function pick(%-*s%-*s): TAction; overload;', [WIDTH_PARAM_NAME, 'const aBoolean: boolean; const aTrueProc' + ': ', WIDTH_FUNC_TYPE, 'TAProc' + aDefs[i].suffix]));
  end;end;

  case aFuncProc of fpProc:
  for var i := 0 to high(aDefs) do
  begin
    aSL.add(format('    class function pick(%-*s%-*s): TAction; overload;', [WIDTH_PARAM_NAME, 'const aBoolean: boolean; const aTrueProc' + ': ', WIDTH_FUNC_TYPE, 'TAProc' + aDefs[i].suffix + '; const aFalseProc' + ': TAProc' + aDefs[i].suffix]));
  end;end;
end;

procedure writeClassPerforms(const vUnit: string; const aDefs: TDefs; const aSL: TStringList; const aFuncProc: TFuncProc);
const
  WIDTH_PARAMs  = 60;
begin
  var vResult2            := '';
  var vColon              := '';
  var vFunctionProcedure  := 'procedure';
  case aFuncProc of fpFunc: begin
                              vFunctionProcedure  := 'function';
                              vColon              := ': ';
                              vResult2            := 'TResult'; end;end;

  aSL.add('');
  for var i := 0 to high(aDefs) do
    aSL.add(format('    %s  perform(%s)%s; overload;', [vFunctionProcedure, aDefs[i].paramDefs, vColon + vResult2]));


  aSL.add('');
  case (aFuncProc = fpFunc) and (vUnit = BAZ_ACTION_UNIT) of TRUE: aSL.add('    class function startWith(const aBoolean: boolean): TAction<TResult>;'); end;
  case (aFuncProc = fpFunc) and (vUnit = BAZ_ACTION_UNIT) of TRUE: aSL.add('    class function startWithNot(const aBoolean: boolean): TAction<TResult>;'); end;

  aSL.add('');
  case aFuncProc of fpFunc:
    for var i := 0 to length(aDefs) - 1 do begin
       aSL.add(format('    function  andThen(const aGuardClause: boolean; const aTrueFunc: TAFunc%s<boolean>; %s): TAction<TResult>; overload;', [aDefs[i].suffix, aDefs[i].paramDefs]));
    end;end;

  aSL.add('');
  case aFuncProc of fpFunc:
    for var i := 0 to length(aDefs) - 1 do begin
       aSL.add(format('    function  aside(const aGuardClause: boolean; const aTrueFunc: TAFunc%s<boolean>; %s): TAction<TResult>; overload;', [aDefs[i].suffix, aDefs[i].paramDefs]));
    end;end;

  aSL.add('');
  case aFuncProc of fpFunc:
    for var i := 0 to length(aDefs) - 1 do begin
       aSL.add(format('    function  aside<T>(const aGuardClause: boolean; const aTrueFunc: TAFunc%s<T>; %s): TAction<TResult>; overload;', [aDefs[i].suffix, aDefs[i].paramDefs]));
    end;end;

  case (aFuncProc = fpFunc) and (vUnit = BAZ_ACTION_UNIT) of TRUE:  begin
                                                                      aSL.add('');
                                                                      aSL.add('    function  thenStop: boolean;');
                                                                      aSL.add('');
                                                                      aSL.add('    property  success:        boolean read getSuccess         write setSuccess;'); end;end;

   case vUnit = BAZ_ACTION_UNIT of TRUE: aSL.add('    property  methodAssigned: boolean read getMethodAssigned  write setMethodAssigned;'); end;

  aSL.add('  end;');
end;

procedure writeImplementationHeader(const aSL: TStringList; const aFuncProc: TFuncProc);
begin
  var vResult1 := '';
  case aFuncProc of fpFunc: vResult1 := '<TResult>'; end;
  aSL.add('');
  aSL.add('implementation');
  aSL.add('');

  case aFuncProc of fpFunc: begin
                              aSL.add('uses');
                              aSL.add('  bazRTL;'); end;end;
end;

procedure writeConstructorsFixed(aDefs: TDefs; const aSL: TStringList; const aFuncProc: TFuncProc);
begin
  var vResult1  := '';
  var vFuncProc := 'Proc';
  case aFuncProc of fpFunc: begin
                              vResult1 := '<TResult>';
                              vFuncProc := 'Func'; end;end;


  aSL.add('');
  aSL.add(format('{ TAction%s }', [vResult1]));

  aSL.add('');
  aSL.add(format('constructor TAction%s.Create;', [vResult1]));
  aSL.add('begin');
  aSL.add('  raise exception.create(''Don''''t call TAction.create'');');
  aSL.add('end;');
  aSL.add('');

  aSL.add(format('constructor TAction%s.Create(const a%sNIL: pointer);', [vResult1, vFuncProc]));
  aSL.add('begin');
  aSL.add(format('  case a%sNIL = NIL of   TRUE: EXIT;', [vFuncProc]));
  aSL.add('                          FALSE: raise exception.Create(''Methodless constructor must be called with NIL''); end;');
  aSL.add('end;');
end;

procedure writeConstructors(const aDefs: TDefs; const aSL: TStringList; const aFuncProc: TFuncProc);
const
  WIDTH_PARAM_NAME  = 16;
  WIDTH_FUNC_TYPE   = 10;
  WIDTH_FIELD_NAME  = 20;
begin
  case aFuncProc of fpFunc:
  for var i := 0 to high(aDefs) do
  begin
    aSL.add(format('constructor TAction<TResult>.Create(const aFunc%s: TAFunc%s<TResult>);', [aDefs[i].suffix, aDefs[i].suffix]));
    aSL.add('begin');
    aSL.add(format('  %-*s := aFunc%s;', [WIDTH_FIELD_NAME, 'FAFunc' + aDefs[i].suffix, aDefs[i].suffix]));
    aSL.add(format('  %-*s := assigned(aFunc%s);', [WIDTH_FIELD_NAME, 'methodAssigned', aDefs[i].suffix]));
    aSL.add('end;');
    aSL.add('');
  end;end;

  case aFuncProc of fpProc:
  for var i := 0 to high(aDefs) do
  begin
    aSL.add(format('constructor TAction.Create(const aProc%s: TAProc%s);', [aDefs[i].suffix, aDefs[i].suffix]));
    aSL.add('begin');
    aSL.add(format('  %-*s := aProc%s;', [WIDTH_FIELD_NAME, 'FAProc' + aDefs[i].suffix, aDefs[i].suffix]));
    aSL.add(format('  %-*s := assigned(aProc%s);', [WIDTH_FIELD_NAME, 'methodAssigned', aDefs[i].suffix]));
    aSL.add('end;');
    aSL.add('');
  end;end;
end;

procedure writePicksTrueFunc(const aDefs: TDefs; const aSL: TStringList; const aFuncProc: TFuncProc);
begin
  var vResult1            := '';
  var vFuncProc           := 'Proc';
  var vFunctionProcedure  := 'procedure';
  case aFuncProc of fpFunc: begin
                              vResult1 := '<TResult>';
                              vFuncProc := 'Func';
                              vFunctionProcedure := 'function'; end;end;

  // picks are always functions
  for var i := 0 to high(aDefs) do
  begin

    var vPointerPrefix: string := '';
    var vPointerSuffix: string := '';

    aSL.add(format('class function TAction%s.pick(const aBoolean: boolean; const aTrue%s: TA%s%s%s): TAction%s;', [vResult1, vFuncProc, vFuncProc, aDefs[i].suffix, vResult1, vResult1]));
    aSL.add('begin');
    aSL.add('  case aBoolean of');
    aSL.add(format('     TRUE:  result := %sTAction%s.Create(aTrue%s)%s;', [vPointerPrefix, vResult1, vFuncProc, vPointerSuffix]));
    aSL.add(format('    FALSE:  result := %sTAction%s.Create(NIL)%s;',     [vPointerPrefix, vResult1, vPointerSuffix]));
    aSL.add('  end;');
    aSL.add('end;');
    aSL.add('');
  end;
end;

procedure writePicksTrueFalseFunc(const aDefs: TDefs; const aSL: TStringList; const aFuncProc: TFuncProc);
begin
  var vResult1            := '';
  var vFuncProc           := 'Proc';
  var vFunctionProcedure  := 'procedure';
  case aFuncProc of fpFunc: begin
                              vResult1            := '<TResult>';
                              vFuncProc           := 'Func';
                              vFunctionProcedure  := 'function'; end;end;

  var vPointerPrefix: string := '';
  var vPointerSuffix: string := '';

  // picks are always functions
  for var i := 0 to high(aDefs) do
  begin
    aSL.add(format('class function TAction%s.pick(const aBoolean: boolean; const aTrue%s: TA%s%s%s; const aFalse%s: TA%s%s%s): TAction%s;', [vResult1, vFuncProc, vFuncProc, aDefs[i].suffix, vResult1, vFuncProc, vFuncProc, aDefs[i].suffix, vResult1, vResult1]));
    aSL.add('begin');
    aSL.add('  case aBoolean of');
    aSL.add(format('     TRUE:  result := %sTAction%s.Create(aTrue%s)%s;',  [vPointerPrefix, vResult1, vFuncProc, vPointerSuffix]));
    aSL.add(format('    FALSE:  result := %sTAction%s.Create(aFalse%s)%s;', [vPointerPrefix, vResult1, vFuncProc, vPointerSuffix]));
    aSL.add('  end;');
    aSL.add('end;');
    aSL.add('');
  end;
end;

procedure writePerforms(const vUnit: string; const aDefs: TDefs; const aSL: TStringList; const aFuncProc: TFuncProc);
begin
  var vResult1            := '';
  var vResult2            := '';
  var vColon              := '';
  var vFuncProc           := 'Proc';
  var vFunctionProcedure  := 'procedure';

  case aFuncProc of fpFunc: begin
                              vFunctionProcedure  := 'function';
                              vColon              := ': ';
                              vResult1            := '<TResult>';
                              vResult2            := 'TResult'; end;end;

  case                          (vUnit = BAZ_ACTION_UNIT) of TRUE:  begin
                                                                      aSL.add('');
                                                                      aSL.add(format('function TAction%s.getMethodAssigned: boolean;', [vResult1]));
                                                                      aSL.add('begin');
                                                                      aSL.add('  result := FMethodAssigned;');
                                                                      aSL.add('end;');
                                                                      aSL.add('');
                                                                      aSL.add(format('procedure TAction%s.setMethodAssigned(const aValue: boolean);', [vResult1]));
                                                                      aSL.add('begin');
                                                                      aSL.add('  FMethodAssigned := aValue;');
                                                                      aSL.add('end;'); end;end;

  var vPointerPrefix: string := '';
  var vPointerSuffix: string := '';
  case vUnit = BAZ_ACTION_UNIT of FALSE: vPointerPrefix := format('IAction%s(pointer(', [vResult1]); end;
  case vUnit = BAZ_ACTION_UNIT of FALSE: vPointerSuffix := '))'; end;

  case (aFuncProc = fpFunc) and (vUnit = BAZ_ACTION_UNIT) of TRUE:  begin
                                                                      aSL.add('');
                                                                      aSL.add(format('function TAction%s.default(const aValue: TResult): TAction%s;', [vResult1, vResult1]));
                                                                      aSL.add('begin');
                                                                      aSL.add('  FDefault := aValue;');
                                                                      aSL.add(format('  result   := %sSELF%s;', [vPointerPrefix, vPointerSuffix]));
                                                                      aSL.add('end;');
                                                                      aSL.add('');
                                                                      aSL.add(format('function TAction%s.getDefault: TResult;', [vResult1]));
                                                                      aSL.add('begin');
                                                                      aSL.add('  result := FDefault');
                                                                      aSL.add('end;'); end;end;

  case (aFuncProc = fpFunc) and (vUnit = BAZ_ACTION_UNIT) of TRUE:  begin         // needs to work in non-generic TAction too at some point
                                                                      aSL.add('');
                                                                      aSL.add(format('function TAction%s.ensure(const aGuardClause: boolean): TAction%s;', [vResult1, vResult1]));
                                                                      aSL.add('begin');
                                                                      aSL.add('  success := success and aGuardClause;');
                                                                      aSL.add('  result := SELF;');
                                                                      aSL.add('end;'); end;end;

  case (aFuncProc = fpFunc) and (vUnit = BAZ_ACTION_UNIT) of TRUE:  begin // needs to work in non-generic TAction too at some point
                                                                      aSL.add('');
                                                                      aSL.add('function TAction<TResult>.assign<T>(var aTarget: T; const aValue: T): TAction<TResult>;');
                                                                      aSL.add('begin');
                                                                      aSL.add('  case success of TRUE: aTarget := aValue; end;');
                                                                      aSL.add('  result  := SELF;');
                                                                      aSL.add('end;'); end;end;

  case (aFuncProc = fpFunc) and (vUnit = BAZ_ACTION_UNIT) of TRUE:  begin // needs to work in non-generic TAction too at some point
                                                                      aSL.add('');
                                                                      aSL.add('function TAction<TResult>.assign<T>(const aGuardClause: boolean; var aTarget: T; const aValue: T): TAction<TResult>;');
                                                                      aSL.add('begin');
                                                                      aSL.add('  case success and aGuardClause of TRUE: aTarget := aValue; end;');
                                                                      aSL.add('  result  := SELF;');
                                                                      aSL.add('end;'); end;end;

  case (aFuncProc = fpFunc) and (vUnit = BAZ_ACTION_UNIT) of TRUE:  begin // needs to work in non-generic TAction too at some point
                                                                      aSL.add('');
                                                                      aSL.add('function TAction<TResult>.assignFrom<T>(var aTarget: T; const aValue: TFunc<T>): TAction<TResult>;');
                                                                      aSL.add('begin');
                                                                      aSL.add('  case success of TRUE: aTarget := aValue(); end;');
                                                                      aSL.add('  result  := SELF;');
                                                                      aSL.add('end;'); end;end;

  case (aFuncProc = fpFunc) and (vUnit = BAZ_ACTION_UNIT) of TRUE:  begin // needs to work in non-generic TAction too at some point
                                                                      aSL.add('');
                                                                      aSL.add('function TAction<TResult>.assignFrom<T>(const aGuardClause: boolean; var aTarget: T; const aValue: TFunc<T>): TAction<TResult>;');
                                                                      aSL.add('begin');
                                                                      aSL.add('  case success and aGuardClause of TRUE: aTarget := aValue(); end;');
                                                                      aSL.add('  result  := SELF;');
                                                                      aSL.add('end;'); end;end;


  for var i := 0 to high(aDefs) do
  begin
    aSL.add('');
    aSL.add(format('%s TAction%s.perform(' + aDefs[i].paramDefs + ')%s%s;', [vFunctionProcedure, vResult1, vColon, vResult2]));
    aSL.add('begin');
    case aFuncProc of fpFunc: begin
    aSL.add('  result := getDefault;');
    aSL.add('  try');
    aSL.add('    case assigned(FAFunc' + aDefs[i].suffix + ') of TRUE: EXIT(FAFunc' + aDefs[i].suffix + '(' + aDefs[i].paramList + ')); end;'); end;end;

    case aFuncProc of fpProc: begin
    aSL.add('  try');
    aSL.add('    case assigned(FAProc' + aDefs[i].suffix + ') of TRUE: FAProc' + aDefs[i].suffix + '(' + aDefs[i].paramList + '); end;'); end;end;

    aSL.add('  finally');
    aSL.add('    SELF.free;');
    aSL.add('  end;');
    aSL.add('end;');
  end;
end;

procedure writeAndThens(const vUnit: string; const aDefs: TDefs; const aSL: TStringList; const aFuncProc: TFuncProc);
begin
  case aFuncProc of fpFunc:
  for var i := 0 to high(aDefs) do begin
    var vTOTSTA := 'TA';
    for var j := 1 to 1 do begin
      aSL.add('');
      aSL.add(format('function TAction<TResult>.andThen(const aGuardClause: boolean; const aTrueFunc: %sFunc%s<boolean>; %s): TAction<TResult>;', [vTOTSTA, aDefs[i].suffix, aDefs[i].paramDefs]));
      aSL.add('begin');
      aSL.add(format('  case success and aGuardClause of TRUE: success := aTrueFunc(%s); end;', [aDefs[i].paramList]));
      aSL.add('  result := SELF;');
      aSL.add('end;');
      case vTOTSTA = 'TS' of TRUE: vTOTSTA := 'TA'; end;
      case vTOTSTA = 'TO' of TRUE: vTOTSTA := 'TS'; end;
    end;end;end;

  case aFuncProc of fpFunc:
  for var i := 0 to high(aDefs) do begin
    var vTOTSTA := 'TA';
    for var j := 1 to 1 do begin
      aSL.add('');
      aSL.add(format('function TAction<TResult>.aside(const aGuardClause: boolean; const aTrueFunc: %sFunc%s<boolean>; %s): TAction<TResult>;', [vTOTSTA, aDefs[i].suffix, aDefs[i].paramDefs]));
      aSL.add('begin');
      aSL.add(format('  case success and aGuardClause of TRUE: aTrueFunc(%s); end;', [aDefs[i].paramList]));
      aSL.add('  result := SELF;');
      aSL.add('end;');
      case vTOTSTA = 'TS' of TRUE: vTOTSTA := 'TA'; end;
      case vTOTSTA = 'TO' of TRUE: vTOTSTA := 'TS'; end;
    end;end;end;

  case aFuncProc of fpFunc:
  for var i := 0 to high(aDefs) do begin
    var vTOTSTA := 'TA';
    for var j := 1 to 1 do begin
      aSL.add('');
      aSL.add(format('function TAction<TResult>.aside<T>(const aGuardClause: boolean; const aTrueFunc: %sFunc%s<T>; %s): TAction<TResult>;', [vTOTSTA, aDefs[i].suffix, aDefs[i].paramDefs]));
      aSL.add('begin');
      aSL.add(format('  case success and aGuardClause of TRUE: aTrueFunc(%s); end;', [aDefs[i].paramList]));
      aSL.add('  result := SELF;');
      aSL.add('end;');
      case vTOTSTA = 'TS' of TRUE: vTOTSTA := 'TA'; end;
      case vTOTSTA = 'TO' of TRUE: vTOTSTA := 'TS'; end;
    end;end;end;

  case (aFuncProc = fpFunc) and (vUnit = BAZ_ACTION_UNIT) of TRUE: begin
    aSL.add('');
    aSL.add('function TAction<TResult>.getSuccess: boolean;');
    aSL.add('begin');
    aSL.add('  result := FSuccess;');
    aSL.add('end;');

    aSL.add('');
    aSL.add('procedure TAction<TResult>.setSuccess(const aValue: boolean);');
    aSL.add('begin');
    aSL.add('  FSuccess := aValue;');
    aSL.add('end;');

    aSL.add('');
    aSL.add('class function TAction<TResult>.startWith(const aBoolean: boolean): TAction<TResult>;');
    aSL.add('begin');
    aSL.add('  result             := TAction<TResult>.Create(NIL);');
    aSL.add('  result.success     := aBoolean;');
    aSL.add('end;');

    aSL.add('');
    aSL.add('class function TAction<TResult>.startWithNot(const aBoolean: boolean): TAction<TResult>;');
    aSL.add('begin');
    aSL.add('  result             := TAction<TResult>.Create(NIL);');
    aSL.add('  result.success     := NOT aBoolean;');
    aSL.add('end;');

    aSL.add('');
    aSL.add('function TAction<TResult>.thenStop: boolean;');
    aSL.add('begin');
    aSL.add('  result := FSuccess;');
    aSL.add('  SELF.free;');
    aSL.add('end;');
  end;end;
end;

function copySection(const vUnit: string; const aHeader: string; const aFilePath: string; const aSL: TStringList): TVoid;
begin
  var vInput := TStringList.create;
  try
    vInput.loadFromFile(aFilePath);
    var vCopying: boolean := FALSE;

    for var vLine: string in vInput do
    begin
      case (aHeader = '') and (vLine.startsWith(':')) of TRUE:  begin
                                                                  aSL.add(format('unit %s;', [vUnit]));
                                                                  BREAK; end;end;

      vCopying := vCopying and NOT vLine.startsWith('#');

      case vCopying of TRUE: aSL.add(vLine); end;

      vCopying := vCopying or (vLine = aHeader);
    end;

  finally
    vInput.free;
  end;
end;

function getUnit(const aFilePath: string): string;
begin
  var vInput := TStringList.create;
  try
    vInput.loadFromFile(aFilePath);

    for var vLine: string in vInput do
    begin
      case (vLine.startsWith(':')) of TRUE: begin
                                              result := copy(vLine, 2, maxInt);
                                              BREAK; end;end;
    end;

  finally
    vInput.free;
  end;
end;

procedure writeUnit(const vUnit: string; const aDefs: TDefs; const aFilePathIn: string);
begin
  var vSL := TStringList.Create;
  try

// "unit" and "uses"
    copySection(vUnit, '#' + vUnit + ' copyright', aFilePathIn, vSL);
    copySection(vUnit, '',  aFilePathIn, vSL); // write out the unit name
    writeUnitHeader(vUnit, vSL);
    copySection(vUnit, '#' + vUnit + ' uses',  aFilePathIn, vSL);

// Function and Procedure Types
    writeType                 (vUnit, aDefs, vSL, fpFunc);
//    writeTypes                (vUnit, aDefs, vSL, fpFunc);
//    writeTypes                (vUnit, aDefs, vSL, fpProc);

// interface and class definitions functions
//    writeInterface            (aDefs, vSL, fpFunc); // interface definition, not the interface section header
    writeClassHeader          (vUnit, aDefs, vSL, fpFunc);
    writeClassMembers         (vUnit, aDefs, vSL, fpFunc);
    writeClassConstructors    (       aDefs, vSL, fpFunc);
    writeClassPicks           (vUnit, aDefs, vSL, fpFunc);
    writeClassPerforms        (vUnit, aDefs, vSL, fpFunc);

// interface and class definitions procedures
//    writeInterface            (aDefs, vSL, fpProc); // interface definition, not the interface section header
    writeClassHeader          (vUnit, aDefs, vSL, fpProc);
    writeClassMembers         (vUnit, aDefs, vSL, fpProc);
    writeClassConstructors    (       aDefs, vSL, fpProc);
    writeClassPicks           (vUnit, aDefs, vSL, fpProc);
    writeClassPerforms        (vUnit, aDefs, vSL, fpProc);

// implementation section functions
    writeImplementationHeader (              vSL, fpFunc);
    writeConstructorsFixed    (       aDefs, vSL, fpFunc);
    writeConstructors         (       aDefs, vSL, fpFunc);
    writePicksTrueFunc        (       aDefs, vSL, fpFunc);
    writePicksTrueFalseFunc   (       aDefs, vSL, fpFunc);
    writePerforms             (vUnit, aDefs, vSL, fpFunc);
    writeAndThens             (vUnit, aDefs, vSL, fpFunc);

// implementation section procedures
//    writeImplementationHeader (       vSL, fpProc);
    writeConstructorsFixed    (       aDefs, vSL, fpProc);
    writeConstructors         (       aDefs, vSL, fpProc);
    writePicksTrueFunc        (       aDefs, vSL, fpProc);
    writePicksTrueFalseFunc   (       aDefs, vSL, fpProc);
    writePerforms             (vUnit, aDefs, vSL, fpProc);

    vSL.add('');
    vSL.add('end.');

    for var i := 0 to vSL.count - 1 do
      vSL[i] := stringReplace(vSL[i], '; )', ')', []);

    vSL.saveToFile(vUnit + '.pas');
  finally
    vSL.free;
  end;
end;

function getNames(const aDataTypes: TArray<string>): TArray<string>;
begin
  result      := copy(aDataTypes);
  var vTotals := TDictionary<string, integer>.create;
  var vCounts := TDictionary<string, integer>.create;

  try

    for var vType in aDataTypes do vTotals.addOrSetValue(vType, 0);
    for var vType in aDataTypes do vCounts.addOrSetValue(vType, 0);

    for var vType in aDataTypes do vTotals.addOrSetValue(vType, vTotals.items[vType] + 1);

    for var i := low(result) to high(result) do
    begin
      var vType := result[i];
      vCounts.addOrSetValue(vType, vCounts.items[vType] + 1);

      case vTotals.items[vType] > 1 of TRUE: result[i] := vType + vCounts.items[vType].toString; end;
    end;

  finally
    vCounts.free;
    vTotals.free;
  end;
end;

procedure readDefs(const vUnit: string; var aDefs: TDefs; const aFilePath: string);
begin
  var vLines := TStringList.Create;
  try
    vLines.loadFromFile(aFilePath);

    var vStartIx  := vLines.indexOf('#' + vUnit + ' types') + 1;
    var vEndIx    := vLines.count - 1;
    for var i := vStartIx to vLines.count - 1 do begin
      case vLines[i].startsWith('#') of TRUE: begin
                                                vEndIx := i - 1;
                                                BREAK; end;end;
    end;
    setLength(aDefs, vEndIx - vStartIx);

    var vDefIx := -1;

    for var i := vStartIx to vEndIx do
    begin
      var vLine := trim(vLines[i]);

      // data validity checks
      var vLineParts := vLine.split([':'], TStringSplitOptions.ExcludeEmpty); // for a no-params suffix, the terminating colon in optional
      case length(vLineParts) = 0 of TRUE: CONTINUE; end;                     // line contains nothing

      // line contains at least a record type suffix in element [0]

      var vDataTypes: TArray<string>;                                         // if datatypes are included, the record type suffix must be terminated by a colon
      case length(vLineParts) > 1 of TRUE: vDataTypes := vLineParts[1].split([' '], TStringSplitOptions.ExcludeEmpty); end; // datatypes must be separated with a space

      var vNames := getNames(vDataTypes);

      // data accepted
      inc(vDefIx);

      aDefs[vDefIx].suffix := vLineParts[0];

      var vParamDefs := '';
      var vParamList := '';
      var vSemiColon := '';
      var vComma     := '';

      for var j := 0 to length(vDataTypes) - 1 do
      begin
        vParamDefs := vParamDefs + format('%sconst a%s: %s', [vSemiColon, upperCase(vNames[j][1]) + copy(vNames[j], 2, maxInt), vDataTypes[j]]);
        vParamList := vParamList + format('%sa%s', [vComma, upperCase(vNames[j][1]) + copy(vNames[j], 2, maxInt)]);
        vSemiColon := '; ';
        vComma     := ', ';
      end;

      aDefs[vDefIx].paramDefs := vParamDefs;
      aDefs[vDefIx].paramList := vParamList;
    end;

    setLength(aDefs, vDefIx + 1); // readjust for over-allocation in the event of rejected lines
  finally
    vLines.free;
  end;
end;

function writeFuncDefs(const vUnit: string; var aDefs: TDefs; const aFilePathIn: string): TVoid;
const BAZ_FUNC_DEFS = 'bazFuncDefs';
begin
  var vSL2 := TStringList.create;
  try
    copySection       (BAZ_FUNC_DEFS, '#bazAction copyright', aFilePathIn, vSL2);
    copySection       (BAZ_FUNC_DEFS, '',                     aFilePathIn, vSL2); // write out the unit name
    writeUnitHeader   (BAZ_FUNC_DEFS,                                      vSL2);
    // copySection       (BAZ_FUNC_DEFS, '#bazFuncDefs uses',      aFilePathIn, vSL2); // doesn't "use" anything

    // ideally, this should find "#bazAction types" and "#mmpAction types" etc entries automatically rather than hard-coding them
    setLength(aDefs, 0);
    vSL2.add('type');
    vSL2.add('  TVoid = record end;');
    readDefs('bazAction',   aDefs, aFilePathIn);
    writeTypes('bazAction', aDefs, vSL2, fpFunc);
    writeTypes('bazAction', aDefs, vSL2, fpProc);

    setLength(aDefs, 0);
    readDefs('mmpAction',   aDefs, aFilePathIn);
    writeTypes('mmpAction', aDefs, vSL2, fpFunc);
    writeTypes('mmpAction', aDefs, vSL2, fpProc);

    vSL2.add('');
    vSL2.add('implementation');
    vSL2.add('');
    vSL2.add('end.');
    vSL2.saveToFile(BAZ_FUNC_DEFS + '.pas');
  finally
    vSL2.free;
  end;
end;


function test(const aString: string; const aBoolean: boolean): boolean;
begin
  writeln(aString + ' from mmpAction');
end;

procedure testReadDefs(const vUnit: string; const aFilePath: string);
var
  vDefs: TDefs;
begin
  readDefs(vUnit, vDefs, aFilePath);

  for var i := 0 to length(vDefs) - 1 do
  begin
    writeln('Suffix: ', vDefs[i].suffix);
    writeln('Params: ', vDefs[i].paramDefs);
    writeln('----------------------');
  end;
end;

function soTrue: boolean;
begin
  result := TRUE;
end;

function sayItsTrue: boolean;
begin
  writeLn('It''s twoo! It''s twoo!');
  result := TRUE;
end;

function whisperSweetNothings: boolean;
begin
  writeLn('Wut?');
  result := FALSE;
end;

begin
  try
    // testReadDefs('bazActionDefs.txt');

    var vUnit := getUnit(FILE_PATH_IN); // obtain vUnit only

    readDefs      (vUnit, vDefs, FILE_PATH_IN);
    writeUnit     (vUnit, vDefs, FILE_PATH_IN);
    writeFuncDefs (vUnit, vDefs, FILE_PATH_IN);

    var vResult := TAction<boolean>.pick(TRUE, test).perform('hello', TRUE);

    var result := TAction<boolean>.startWith(TRUE)
                    .ensure(TRUE)
                    .andThen(TRUE, function:boolean begin writeln('first andThen'); result := TRUE; end)
                    .andThen(TRUE, function:boolean begin writeln('second andThen'); result := TRUE; end)
                    .aside(TRUE, whisperSweetNothings)
                    .andthen(TRUE, sayItsTrue)
                    .andThen(TRUE, soTrue)
                    .thenStop;

    case result of   TRUE: writeln('TWOO...I mean, TRUE');
                    FALSE: writeln('FALSE'); end;

//    var vTestParts := 'LoadsASpaces:  boolean  string           '.split([' ']);
//    var vTestParts := 'StringInteger: string integer'.split([':']);
//    var vTestParts := 'Boolean: boolean'.split([':'], TStringSplitOptions.ExcludeEmpty);
//    var vTestParts := ' boolean'.split([' '], TStringSplitOptions.ExcludeEmpty);
//    var vTestParts := 'NoParam:'.split([':'], TStringSplitOptions.ExcludeEmpty);
//    var vTestParts := 'NoParam'.split([':'], TStringSplitOptions.ExcludeEmpty);
//    writeLn(intToStr(length(vTestParts)));
//    writeLn(vTestParts[0]);
//    writeLn('>' + vTestParts[1] + '<');
  except
    on E: Exception do
      Writeln(E.ClassName, ': ', E.Message);
  end;
end.
