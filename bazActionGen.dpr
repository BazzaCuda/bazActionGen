program bazActionGen;

{   bazActionGen
    Copyright (C) 2021-2099 Baz Cuda
    https://github.com/BazzaCuda/bazActionGen

    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307, USA
}

{$APPTYPE CONSOLE}

{$R *.res}

uses
  system.classes,
  system.generics.collections,
  system.sysUtils,
  vcl.dialogs,
  bazAction in 'Win64\Debug\bazAction.pas',
//  mmpAction in 'Win64\Debug\mmpAction.pas',
  bazRTL in '..\_MVVM\_bazLib\bazRTL.pas';

type
  TDef = record
    suffix: string;
    paramDefs: string;
    paramList: string;
  end;

  TDefs = array of TDef;

  TVoid = record end;

  TFuncProc = (fpFunc, fpProc);

const
  BAZ_ACTION_UNIT   = 'bazAction';
  FILE_PATH_IN      = 'bazActionDefs.txt';
  FILE_PATH_OUT     = 'bazAction.pas';

var
  vDefs: TDefs;
  vUnit: string = '';

procedure writeUnitHeader(const aSL: TStringList);
begin
//  aSL.add('''
//{   bazLib / bazAction
//    Copyright (C) 2021-2099 Baz Cuda
//    https://github.com/BazzaCuda/
//
//    This program is free software; you can redistribute it and/or modify
//    it under the terms of the GNU General Public License as published by
//    the Free Software Foundation; either version 3 of the License, or
//    (at your option) any later version.
//
//    This program is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//    GNU General Public License for more details.
//
//    You should have received a copy of the GNU General Public License
//    along with this program; if not, write to the Free Software
//    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307, USA
//
//''' + '}');
//  aSL.add('unit bazAction;');

  aSL.add('');
  aSL.add('interface');
  aSL.add('');
  aSL.add('{ THIS UNIT IS GENERATED BY bazActionGen.exe. AMEND THE bazActionDefs.txt FILE TO REGENERATE THIS UNIT FOR DIFFERENT FUNCTION TYPES AND FUNCTION SIGNATURES }');
  case vUnit = BAZ_ACTION_UNIT of  TRUE: aSL.add('{ Add project-specific datatypes to IAction and TAction descendants in a separate unit }');
                                  FALSE: aSL.add('{ These are project-specific datatypes added via identically-named descendants of bazAction.IAction and bazAction.TAction }'); end;
  aSL.add('');
end;

procedure writeTypes(const aDefs: TDefs; const aSL: TStringList; const aFuncProc: TFuncProc);
const
  WIDTH_SUFFIX = 20;
  WIDTH_PARAMS = 80;
begin
  case aFuncProc of fpFunc: begin
                              aSL.add('type');
                              case vUnit = BAZ_ACTION_UNIT of  TRUE: aSL.add('  TVoid = record end;');
                                                              FALSE: aSL.add('  TVoid = bazAction.TVoid;'); end;end;end;
  aSL.add('');

  var vFuncPrefix := '';

  var vResult1            := '';
  var vResult2            := '';
  var vFuncProc           := 'Proc';
  var vFunctionProcedure  := 'procedure';
  case aFuncProc of fpFunc: begin
                              vFunctionProcedure  := 'function';
                              vFuncProc           := 'Func';
                              vResult1            := '<TResult>';
                              vResult2            := 'TResult'; end;end;

  var vColon := '';
  case aFuncProc of fpFunc: vColon := ':'; end;

  for var i := 0 to length(aDefs) - 1 do begin
    vFuncPrefix := format('%s(' + aDefs[i].paramDefs + ')%s', [vFunctionProcedure, vColon]);
    aSL.add(format('  TO%s%-*s%s = %-*s%s of object; // method of class instance', [vFuncProc, WIDTH_SUFFIX, aDefs[i].suffix, vResult1, WIDTH_PARAMS, vFuncPrefix, vResult2]));

    vFuncPrefix := format('%s(' + aDefs[i].paramDefs + ')%s', [vFunctionProcedure, vColon]);
    aSL.add(format('  TS%s%-*s%s = %-*s%s;           // static method - no class instance', [vFuncProc, WIDTH_SUFFIX, aDefs[i].suffix, vResult1, WIDTH_PARAMS, vFuncPrefix, vResult2]));

    vFuncPrefix := format('reference to %s(' + aDefs[i].paramDefs + ')%s', [vFunctionProcedure, vColon]);
    aSL.add(format('  TA%s%-*s%s = %-*s%s;           // anonymous method', [vFuncProc, WIDTH_SUFFIX, aDefs[i].suffix, vResult1, WIDTH_PARAMS, vFuncPrefix, vResult2]));
  end;
end;

procedure writeInterface(const aDefs: TDefs; const aSL: TStringList; const aFuncProc: TFuncProc);
const
  WIDTH_PARAMS = 4;
begin
  var vResult1            := '';
  var vResult2            := '';
  var vColon              := '';
  var vFunctionProcedure  := 'procedure';
  case aFuncProc of fpFunc: begin
                              vFunctionProcedure  := 'function';
                              vColon              := ': ';
                              vResult1            := '<TResult>';
                              vResult2            := 'TResult'; end;end;

  aSL.add('');
  case vUnit = BAZ_ACTION_UNIT of  TRUE: aSL.add(format('  IAction%s = interface', [vResult1]));
                                  FALSE: aSL.add(format('  IAction%s = interface(bazAction.IAction%s)', [vResult1, vResult1])); end;

  aSL.add(format('    function default(const aValue: %s): IAction%s; // the fallback value', [vResult2, vResult1])); // correct as a function
  aSL.add('');

  for var i := 0 to length(aDefs) - 1 do
    aSL.add(format('    %s perform(%s)%s; overload;', [vFunctionProcedure, aDefs[i].paramDefs, vColon + vResult2]));

  aSL.add('');
  aSL.add('    function getAssigned: boolean;'); // correct as a function
  aSL.add('    property assigned:    boolean read getAssigned;');
  aSL.add('  end;');
end;

procedure writeClassHeader(const aDefs: TDefs; const aSL: TStringList; const aFuncProc: TFuncProc);
begin
  var vResult1            := '';
  case aFuncProc of fpFunc: vResult1 := '<TResult>'; end;

  aSL.add('');
  case vUnit = BAZ_ACTION_UNIT of  TRUE: aSL.add(format('  TAction%s = class(TInterfacedObject, IAction%s)', [vResult1, vResult1]));
                                  FALSE: aSL.add(format('  TAction%s = class(bazAction.TAction%s, bazAction.IAction%s)', [vResult1, vResult1, vResult1])); end;
end;

procedure writeClassMembers(const aDefs: TDefs; const aSL: TStringList; const aFuncProc: TFuncProc);
const
  WIDTH_SUFFIX = 30;
begin
  aSL.add('  strict private');
  aSL.add('    FCallAssigned: boolean;');
  case aFuncProc of fpFunc: aSL.add('    FDefault:      TResult; // initialised by constructor, set by optional .default(), used in .perform()'); end;
  aSL.add('');

  var vFuncProc := 'Proc';
  var vResult1  := '';
  case aFuncProc of fpFunc: begin
                              vFuncProc := 'Func';
                              vResult1  := '<TResult>';  end;end;

  for var i := 0 to high(aDefs) do
  begin
    aSL.add(format('    FO%s%-*sTO%s%-*s %s;', [vFuncProc, WIDTH_SUFFIX, aDefs[i].suffix + ':', vFuncProc, WIDTH_SUFFIX, aDefs[i].suffix, vResult1]));
    aSL.add(format('    FS%s%-*sTA%s%-*s %s;', [vFuncProc, WIDTH_SUFFIX, aDefs[i].suffix + ':', vFuncProc, WIDTH_SUFFIX, aDefs[i].suffix, vResult1]));
    aSL.add(format('    FA%s%-*sTA%s%-*s %s;', [vFuncProc, WIDTH_SUFFIX, aDefs[i].suffix + ':', vFuncProc, WIDTH_SUFFIX, aDefs[i].suffix, vResult1]));
    aSL.add('');
  end;
end;

procedure writeClassConstructors(const aDefs: TDefs; const aSL: TStringList; const aFuncProc: TFuncProc);
const
  WIDTH_PARAM_NAME  = 30;
  WIDTH_FUNC_TYPE   = 25;
  WIDTH_GENERIC     = 1;
begin
  var vFuncProc := 'Proc';
  case aFuncProc of fpFunc: vFuncProc := 'Func'; end;

  aSL.add('    constructor Create;                           overload;');
  aSL.add(format('    constructor Create(const a%sNIL: pointer);  overload;', [vFuncProc]));
  aSL.add('');

  case aFuncProc of fpFunc:
  for var i := 0 to high(aDefs) do
  begin
    aSL.add(format('    constructor Create(%-*s%-*s%-*s);     overload;', [WIDTH_PARAM_NAME, 'const aFunc' + aDefs[i].suffix + ':', WIDTH_FUNC_TYPE, 'TOFunc' + aDefs[i].suffix, WIDTH_GENERIC, '<TResult>']));
    aSL.add(format('    constructor Create(%-*s%-*s%-*s);     overload;', [WIDTH_PARAM_NAME, 'const aFunc' + aDefs[i].suffix + ':', WIDTH_FUNC_TYPE, 'TSFunc' + aDefs[i].suffix, WIDTH_GENERIC, '<TResult>']));
    aSL.add(format('    constructor Create(%-*s%-*s%-*s);     overload;', [WIDTH_PARAM_NAME, 'const aFunc' + aDefs[i].suffix + ':', WIDTH_FUNC_TYPE, 'TAFunc' + aDefs[i].suffix, WIDTH_GENERIC, '<TResult>']));
    aSL.add('');
  end;end;

  case aFuncProc of fpProc:
  for var i := 0 to high(aDefs) do
  begin
    aSL.add(format('    constructor Create(%-*s%-*s%-*s);     overload;', [WIDTH_PARAM_NAME, 'const aProc' + aDefs[i].suffix + ':', WIDTH_FUNC_TYPE, 'TOProc' + aDefs[i].suffix, WIDTH_GENERIC, '']));
    aSL.add(format('    constructor Create(%-*s%-*s%-*s);     overload;', [WIDTH_PARAM_NAME, 'const aProc' + aDefs[i].suffix + ':', WIDTH_FUNC_TYPE, 'TSProc' + aDefs[i].suffix, WIDTH_GENERIC, '']));
    aSL.add(format('    constructor Create(%-*s%-*s%-*s);     overload;', [WIDTH_PARAM_NAME, 'const aProc' + aDefs[i].suffix + ':', WIDTH_FUNC_TYPE, 'TAProc' + aDefs[i].suffix, WIDTH_GENERIC, '']));
    aSL.add('');
  end;end;
end;

procedure writeClassPicks(const aDefs: TDefs; const aSL: TStringList; const aFuncProc: TFuncProc);
const
  WIDTH_PARAM_NAME  = 1;
  WIDTH_FUNC_TYPE   = 2;
begin
  var vResult1 := '';
  var vResult2 := '';
  case aFuncProc of fpFunc: begin
                              vResult1 := '<TResult>';
                              vResult2 := 'TResult'; end;end;

  aSL.add('  public');
  aSL.add('    function getAssigned: boolean;');
  case aFuncProc of fpFunc: aSL.add('    function default(const aValue: TResult): IAction<TResult>;'); end;
  aSL.add('');

  case aFuncProc of fpFunc:
  for var i := 0 to high(aDefs) do
  begin
    aSL.add(format('    class function pick(%-*s%-*s<TResult>): IAction<TResult>; overload;', [WIDTH_PARAM_NAME, 'const aBoolean: boolean; const aTrueFunc' + ': ', WIDTH_FUNC_TYPE, 'TOFunc' + aDefs[i].suffix]));
    aSL.add(format('    class function pick(%-*s%-*s<TResult>): IAction<TResult>; overload;', [WIDTH_PARAM_NAME, 'const aBoolean: boolean; const aTrueFunc' + ': ', WIDTH_FUNC_TYPE, 'TSFunc' + aDefs[i].suffix]));
    aSL.add(format('    class function pick(%-*s%-*s<TResult>): IAction<TResult>; overload;', [WIDTH_PARAM_NAME, 'const aBoolean: boolean; const aTrueFunc' + ': ', WIDTH_FUNC_TYPE, 'TAFunc' + aDefs[i].suffix]));
    aSL.add('');
    aSL.add(format('    class function pick(%-*s%-*s<TResult>): IAction<TResult>; overload;', [WIDTH_PARAM_NAME, 'const aBoolean: boolean; const aTrueFunc' + ': ', WIDTH_FUNC_TYPE, 'TOFunc' + aDefs[i].suffix + '<TResult>; const aFalseFunc' + ': TOFunc' + aDefs[i].suffix]));
    aSL.add(format('    class function pick(%-*s%-*s<TResult>): IAction<TResult>; overload;', [WIDTH_PARAM_NAME, 'const aBoolean: boolean; const aTrueFunc' + ': ', WIDTH_FUNC_TYPE, 'TSFunc' + aDefs[i].suffix + '<TResult>; const aFalseFunc' + ': TSFunc' + aDefs[i].suffix]));
    aSL.add(format('    class function pick(%-*s%-*s<TResult>): IAction<TResult>; overload;', [WIDTH_PARAM_NAME, 'const aBoolean: boolean; const aTrueFunc' + ': ', WIDTH_FUNC_TYPE, 'TAFunc' + aDefs[i].suffix + '<TResult>; const aFalseFunc' + ': TAFunc' + aDefs[i].suffix]));
    aSL.add('');
  end;end;

  case aFuncProc of fpProc:
  for var i := 0 to high(aDefs) do
  begin
    aSL.add(format('    class function pick(%-*s%-*s): IAction; overload;', [WIDTH_PARAM_NAME, 'const aBoolean: boolean; const aTrueProc' + ': ', WIDTH_FUNC_TYPE, 'TOProc' + aDefs[i].suffix]));
    aSL.add(format('    class function pick(%-*s%-*s): IAction; overload;', [WIDTH_PARAM_NAME, 'const aBoolean: boolean; const aTrueProc' + ': ', WIDTH_FUNC_TYPE, 'TSProc' + aDefs[i].suffix]));
    aSL.add(format('    class function pick(%-*s%-*s): IAction; overload;', [WIDTH_PARAM_NAME, 'const aBoolean: boolean; const aTrueProc' + ': ', WIDTH_FUNC_TYPE, 'TAProc' + aDefs[i].suffix]));
    aSL.add('');
    aSL.add(format('    class function pick(%-*s%-*s): IAction; overload;', [WIDTH_PARAM_NAME, 'const aBoolean: boolean; const aTrueProc' + ': ', WIDTH_FUNC_TYPE, 'TOProc' + aDefs[i].suffix + '; const aFalseProc' + ': TOProc' + aDefs[i].suffix]));
    aSL.add(format('    class function pick(%-*s%-*s): IAction; overload;', [WIDTH_PARAM_NAME, 'const aBoolean: boolean; const aTrueProc' + ': ', WIDTH_FUNC_TYPE, 'TSProc' + aDefs[i].suffix + '; const aFalseProc' + ': TSProc' + aDefs[i].suffix]));
    aSL.add(format('    class function pick(%-*s%-*s): IAction; overload;', [WIDTH_PARAM_NAME, 'const aBoolean: boolean; const aTrueProc' + ': ', WIDTH_FUNC_TYPE, 'TAProc' + aDefs[i].suffix + '; const aFalseProc' + ': TAProc' + aDefs[i].suffix]));
    aSL.add('');
  end;end;
end;

procedure writeClassPerforms(const aDefs: TDefs; const aSL: TStringList; const aFuncProc: TFuncProc);
const
  WIDTH_PARAMs  = 60;
begin
  var vResult2            := '';
  var vColon              := '';
  var vFunctionProcedure  := 'procedure';
  case aFuncProc of fpFunc: begin
                              vFunctionProcedure  := 'function';
                              vColon              := ': ';
                              vResult2            := 'TResult'; end;end;

  for var i := 0 to high(aDefs) do
    aSL.add(format('    %s perform(%s)%s; overload;', [vFunctionProcedure, aDefs[i].paramDefs, vColon + vResult2]));

  aSL.add('  end;');
  aSL.add('');
end;

procedure writeImplementationHeader(const aSL: TStringList; const aFuncProc: TFuncProc);
begin
  var vResult1 := '';
  case aFuncProc of fpFunc: vResult1 := '<TResult>'; end;
  aSL.add('implementation');
  aSL.add('');

  case aFuncProc of fpFunc: begin
                              aSL.add('uses');
                              aSL.add('  bazRTL;');
                              aSL.add('');end;end;

  aSL.add(format('{ TAction%s }', [vResult1]));
end;

procedure writeConstructorsFixed(aDefs: TDefs; const aSL: TStringList);
begin
  aSL.add('');
  aSL.add('constructor TAction<TResult>.Create;');
  aSL.add('begin');
  aSL.add('  raise exception.create(''Don''''t call TAction.create'');');
  aSL.add('end;');
  aSL.add('');

  aSL.add('constructor TAction<TResult>.Create(const aFuncNIL: pointer);');
  aSL.add('begin');
  aSL.add('  case aFuncNIL = NIL of   TRUE: EXIT;');
  aSL.add('                          FALSE: raise exception.Create(''Functionless constructor must be called with NIL''); end;');
  aSL.add('end;');
end;

procedure writeConstructors(const aDefs: TDefs; const aSL: TStringList; const aFuncProc: TFuncProc);
const
  WIDTH_PARAM_NAME  = 16;
  WIDTH_FUNC_TYPE   = 10;
  WIDTH_FIELD_NAME  = 20;
begin
  case aFuncProc of fpFunc:
  for var i := 0 to high(aDefs) do
  begin
    aSL.add(format('constructor TAction<TResult>.Create(const aFunc%s: TOFunc%s<TResult>);', [aDefs[i].suffix, aDefs[i].suffix]));
    aSL.add('begin');
    aSL.add(format('  %-*s := aFunc%s;', [WIDTH_FIELD_NAME, 'FOFunc' + aDefs[i].suffix, aDefs[i].suffix]));
    aSL.add(format('  %-*s := assigned(aFunc%s);', [WIDTH_FIELD_NAME, 'FCallAssigned', aDefs[i].suffix]));
    aSL.add('end;');
    aSL.add('');

    aSL.add(format('constructor TAction<TResult>.Create(const aFunc%s: TSFunc%s<TResult>);', [aDefs[i].suffix, aDefs[i].suffix]));
    aSL.add('begin');
    aSL.add(format('  %-*s := aFunc%s;', [WIDTH_FIELD_NAME, 'FSFunc' + aDefs[i].suffix, aDefs[i].suffix]));
    aSL.add(format('  %-*s := assigned(aFunc%s);', [WIDTH_FIELD_NAME, 'FCallAssigned', aDefs[i].suffix]));
    aSL.add('end;');
    aSL.add('');

    aSL.add(format('constructor TAction<TResult>.Create(const aFunc%s: TAFunc%s<TResult>);', [aDefs[i].suffix, aDefs[i].suffix]));
    aSL.add('begin');
    aSL.add(format('  %-*s := aFunc%s;', [WIDTH_FIELD_NAME, 'FAFunc' + aDefs[i].suffix, aDefs[i].suffix]));
    aSL.add(format('  %-*s := assigned(aFunc%s);', [WIDTH_FIELD_NAME, 'FCallAssigned', aDefs[i].suffix]));
    aSL.add('end;');
    aSL.add('');
  end;end;

  case aFuncProc of fpProc:
  for var i := 0 to high(aDefs) do
  begin
    aSL.add(format('constructor TAction.Create(const aProc%s: TOProc%s);', [aDefs[i].suffix, aDefs[i].suffix]));
    aSL.add('begin');
    aSL.add(format('  %-*s := aProc%s;', [WIDTH_FIELD_NAME, 'FOProc' + aDefs[i].suffix, aDefs[i].suffix]));
    aSL.add(format('  %-*s := assigned(aProc%s);', [WIDTH_FIELD_NAME, 'FCallAssigned', aDefs[i].suffix]));
    aSL.add('end;');
    aSL.add('');

    aSL.add(format('constructor TAction.Create(const aProc%s: TSProc%s);', [aDefs[i].suffix, aDefs[i].suffix]));
    aSL.add('begin');
    aSL.add(format('  %-*s := aProc%s;', [WIDTH_FIELD_NAME, 'FSProc' + aDefs[i].suffix, aDefs[i].suffix]));
    aSL.add(format('  %-*s := assigned(aProc%s);', [WIDTH_FIELD_NAME, 'FCallAssigned', aDefs[i].suffix]));
    aSL.add('end;');
    aSL.add('');

    aSL.add(format('constructor TAction.Create(const aProc%s: TAProc%s);', [aDefs[i].suffix, aDefs[i].suffix]));
    aSL.add('begin');
    aSL.add(format('  %-*s := aProc%s;', [WIDTH_FIELD_NAME, 'FAProc' + aDefs[i].suffix, aDefs[i].suffix]));
    aSL.add(format('  %-*s := assigned(aProc%s);', [WIDTH_FIELD_NAME, 'FCallAssigned', aDefs[i].suffix]));
    aSL.add('end;');
    aSL.add('');
  end;end;
end;

procedure writePicksTrueFunc(const aDefs: TDefs; const aSL: TStringList; const aFuncProc: TFuncProc);
begin
  for var i := 0 to high(aDefs) do
  begin
    aSL.add(format('class function TAction<TResult>.pick(const aBoolean: boolean; const aTrueFunc: TOFunc%s<TResult>): IAction<TResult>;', [aDefs[i].suffix]));
    aSL.add('begin');
    aSL.add('  case aBoolean of');

    var vPointerPrefix: string := '';
    var vPointerSuffix: string := '';
    case vUnit = BAZ_ACTION_UNIT of FALSE: vPointerPrefix := 'IAction<TResult>(pointer('; end;
    case vUnit = BAZ_ACTION_UNIT of FALSE: vPointerSuffix := '))'; end;

    aSL.add(format('     TRUE:  result := %sTAction<TResult>.Create(aTrueFunc)%s;', [vPointerPrefix, vPointerSuffix]));
    aSL.add(format('    FALSE:  result := %sTAction<TResult>.Create(NIL)%s;', [vPointerPrefix, vPointerSuffix]));
    aSL.add('  end;');
    aSL.add('end;');
    aSL.add('');

    aSL.add(format('class function TAction<TResult>.pick(const aBoolean: boolean; const aTrueFunc: TSFunc%s<TResult>): IAction<TResult>;', [aDefs[i].suffix]));
    aSL.add('begin');
    aSL.add('  case aBoolean of');
    aSL.add(format('     TRUE:  result := %sTAction<TResult>.Create(aTrueFunc)%s;', [vPointerPrefix, vPointerSuffix]));
    aSL.add(format('    FALSE:  result := %sTAction<TResult>.Create(NIL)%s;', [vPointerPrefix, vPointerSuffix]));
    aSL.add('  end;');
    aSL.add('end;');
    aSL.add('');

    aSL.add(format('class function TAction<TResult>.pick(const aBoolean: boolean; const aTrueFunc: TAFunc%s<TResult>): IAction<TResult>;', [aDefs[i].suffix]));
    aSL.add('begin');
    aSL.add('  case aBoolean of');
    aSL.add(format('     TRUE:  result := %sTAction<TResult>.Create(aTrueFunc)%s;', [vPointerPrefix, vPointerSuffix]));
    aSL.add(format('    FALSE:  result := %sTAction<TResult>.Create(NIL)%s;', [vPointerPrefix, vPointerSuffix]));
    aSL.add('  end;');
    aSL.add('end;');
    aSL.add('');
  end;
end;

procedure writePicksTrueFalseFunc(const aDefs: TDefs; const aSL: TStringList);
begin
  for var i := 0 to high(aDefs) do
  begin
    aSL.add(format('class function TAction<TResult>.pick(const aBoolean: boolean; const aTrueFunc: TOFunc%s<TResult>; const aFalseFunc: TOFunc%s<TResult>): IAction<TResult>;', [aDefs[i].suffix, aDefs[i].suffix]));
    aSL.add('begin');
    aSL.add('  case aBoolean of');

    var vPointerPrefix: string := '';
    var vPointerSuffix: string := '';
    case vUnit = BAZ_ACTION_UNIT of FALSE: vPointerPrefix := 'IAction<TResult>(pointer('; end;
    case vUnit = BAZ_ACTION_UNIT of FALSE: vPointerSuffix := '))'; end;

    aSL.add(format('     TRUE:  result := %sTAction<TResult>.Create(aTrueFunc)%s;', [vPointerPrefix, vPointerSuffix]));
    aSL.add(format('    FALSE:  result := %sTAction<TResult>.Create(aFalseFunc)%s;', [vPointerPrefix, vPointerSuffix]));
    aSL.add('  end;');
    aSL.add('end;');
    aSL.add('');

    aSL.add(format('class function TAction<TResult>.pick(const aBoolean: boolean; const aTrueFunc: TSFunc%s<TResult>; const aFalseFunc: TSFunc%s<TResult>): IAction<TResult>;', [aDefs[i].suffix, aDefs[i].suffix]));
    aSL.add('begin');
    aSL.add('  case aBoolean of');
    aSL.add(format('     TRUE:  result := %sTAction<TResult>.Create(aTrueFunc)%s;', [vPointerPrefix, vPointerSuffix]));
    aSL.add(format('    FALSE:  result := %sTAction<TResult>.Create(aFalseFunc)%s;', [vPointerPrefix, vPointerSuffix]));
    aSL.add('  end;');
    aSL.add('end;');
    aSL.add('');

    aSL.add(format('class function TAction<TResult>.pick(const aBoolean: boolean; const aTrueFunc: TAFunc%s<TResult>; const aFalseFunc: TAFunc%s<TResult>): IAction<TResult>;', [aDefs[i].suffix, aDefs[i].suffix]));
    aSL.add('begin');
    aSL.add('  case aBoolean of');
    aSL.add(format('     TRUE:  result := %sTAction<TResult>.Create(aTrueFunc)%s;', [vPointerPrefix, vPointerSuffix]));
    aSL.add(format('    FALSE:  result := %sTAction<TResult>.Create(aFalseFunc)%s;', [vPointerPrefix, vPointerSuffix]));
    aSL.add('  end;');
    aSL.add('end;');
    aSL.add('');
  end;
end;

procedure writePerforms(const aDefs: TDefs; const aSL: TStringList; const aFuncProc: TFuncProc);
begin
  var vResult1 := '';
  case aFuncProc of fpFunc: vResult1 := '<TResult>'; end;

  aSL.add(format('function TAction%s.getAssigned: boolean;', [vResult1]));
  aSL.add('begin');
  aSL.add('  result := FCallAssigned;');
  aSL.add('end;');
  aSL.add('');

  var vPointerPrefix: string := '';
  var vPointerSuffix: string := '';
  case vUnit = BAZ_ACTION_UNIT of FALSE: vPointerPrefix := format('IAction%s(pointer(', [vResult1]); end;
  case vUnit = BAZ_ACTION_UNIT of FALSE: vPointerSuffix := '))'; end;

  aSL.add(format('function TAction%s.default(const aValue: TResult): IAction%s;', [vResult1, vResult1]));
  aSL.add('begin');
  aSL.add('  FDefault := aValue;');
  aSL.add(format('  result   := %sSELF%s;', [vPointerPrefix, vPointerSuffix]));
  aSL.add('end;');
  aSL.add('');

  for var i := 0 to high(aDefs) do
  begin
    aSL.add('function TAction<TResult>.perform(' + aDefs[i].paramDefs + '): TResult;');
    aSL.add('begin');
    aSL.add('  result := FDefault;');
    aSL.add('  case assigned(FOFunc' + aDefs[i].suffix + ') of TRUE: EXIT(FOFunc' + aDefs[i].suffix + '(' + aDefs[i].paramList+ ')); end;');
    aSL.add('  case assigned(FSFunc' + aDefs[i].suffix + ') of TRUE: EXIT(FSFunc' + aDefs[i].suffix + '(' + aDefs[i].paramList + ')); end;');
    aSL.add('  case assigned(FAFunc' + aDefs[i].suffix + ') of TRUE: EXIT(FAFunc' + aDefs[i].suffix + '(' + aDefs[i].paramList + ')); end;');
    aSL.add('end;');
    aSL.add('');
  end;

  aSL.add('end.');
end;

function copySection(const aHeader: string; const aFilePath: string; const aSL: TStringList): TVoid;
begin
  var vInput := TStringList.create;
  try
    vInput.loadFromFile(aFilePath);
    var vCopying: boolean := FALSE;

    for var vLine: string in vInput do
    begin
      case (aHeader = '') and (vLine.startsWith(':')) of TRUE:  begin
                                                                  vUnit := copy(vLine, 2, maxInt);
                                                                  case aSL = NIL of FALSE: aSL.add(format('unit %s;', [vUnit])); end;
                                                                  BREAK; end;end;

      vCopying := vCopying and NOT vLine.startsWith('#');

      case vCopying of TRUE: aSL.add(vLine); end;

      vCopying := vCopying or (vLine = aHeader);
    end;

  finally
    vInput.free;
  end;
end;

procedure writeUnit(const aDefs: TDefs; const aFilePathIn: string);
begin
  var vSL := TStringList.Create;
  try

// "unit" and "uses"
    copySection('#' + vUnit + ' copyright', aFilePathIn, vSL);
    copySection('',  aFilePathIn, vSL); // obtain vUnit and write out the unit name
    writeUnitHeader(vSL);
    copySection('#' + vUnit + ' uses',  aFilePathIn, vSL);

// Function and Procedure Types
    writeTypes(aDefs, vSL, fpFunc);
    writeTypes(aDefs, vSL, fpProc);

// interface and class definitions
    writeInterface            (aDefs, vSL, fpFunc); // interface definition, not the interface section header
    writeClassHeader          (aDefs, vSL, fpFunc);
    writeClassMembers         (aDefs, vSL, fpFunc);
    writeClassConstructors    (aDefs, vSL, fpFunc);
    writeClassPicks           (aDefs, vSL, fpFunc);
    writeClassPerforms        (aDefs, vSL, fpFunc);

// implementation section
    writeImplementationHeader (       vSL, fpFunc);
    writeConstructorsFixed    (aDefs, vSL);
    writeConstructors         (aDefs, vSL, fpFunc);
    writePicksTrueFunc        (aDefs, vSL);
    writePicksTrueFalseFunc   (aDefs, vSL);
    writePerforms             (aDefs, vSL, fpFunc);

    vSL.saveToFile(vUnit + '.pas');
  finally
    vSL.Free;
  end;
end;

function getNames(const aDataTypes: TArray<string>): TArray<string>;
begin
  result      := copy(aDataTypes);
  var vTotals := TDictionary<string, integer>.create;
  var vCounts := TDictionary<string, integer>.create;

  try

    for var vType in aDataTypes do vTotals.addOrSetValue(vType, 0);
    for var vType in aDataTypes do vCounts.addOrSetValue(vType, 0);

    for var vType in aDataTypes do vTotals.addOrSetValue(vType, vTotals.items[vType] + 1);

    for var i := low(result) to high(result) do
    begin
      var vType := result[i];
      vCounts.addOrSetValue(vType, vCounts.items[vType] + 1);

      case vTotals.items[vType] > 1 of TRUE: result[i] := vType + vCounts.items[vType].toString; end;
    end;

  finally
    vCounts.free;
    vTotals.free;
  end;
end;

procedure readDefs(var aDefs: TDefs; const aFilePath: string);
begin
  var vLines := TStringList.Create;
  try
    vLines.loadFromFile(aFilePath);

    var vStartIx  := vLines.indexOf('#' + vUnit + ' types') + 1;
    var vEndIx    := vLines.count - 1;
    for var i := vStartIx to vLines.count - 1 do begin
      case vLines[i].startsWith('#') of TRUE: begin
                                                vEndIx := i - 1;
                                                BREAK; end;end;
    end;
    setLength(aDefs, vEndIx - vStartIx);

    var vDefIx := -1;

    for var i := vStartIx to vEndIx do
    begin
      var vLine := trim(vLines[i]);

      // data validity checks
      var vLineParts := vLine.split([':'], TStringSplitOptions.ExcludeEmpty); // for a no-params suffix, the terminating colon in optional
      case length(vLineParts) = 0 of TRUE: CONTINUE; end;                     // line contains nothing

      // line contains at least a record type suffix in element [0]

      var vDataTypes: TArray<string>;                                         // if datatypes are included, the record type suffix must be terminated by a colon
      case length(vLineParts) > 1 of TRUE: vDataTypes := vLineParts[1].split([' '], TStringSplitOptions.ExcludeEmpty); end; // datatypes must be separated with a space

      var vNames := getNames(vDataTypes);

      // data accepted
      inc(vDefIx);

      aDefs[vDefIx].suffix := vLineParts[0];

      var vParamDefs := '';
      var vParamList := '';
      var vSemiColon := '';
      var vComma     := '';

      for var j := 0 to length(vDataTypes) - 1 do
      begin
        vParamDefs := vParamDefs + format('%sconst a%s: %s', [vSemiColon, upperCase(vNames[j][1]) + copy(vNames[j], 2, maxInt), vDataTypes[j]]);
        vParamList := vParamList + format('%sa%s', [vComma, upperCase(vNames[j][1]) + copy(vNames[j], 2, maxInt)]);
        vSemiColon := '; ';
        vComma     := ', ';
      end;

      aDefs[vDefIx].paramDefs := vParamDefs;
      aDefs[vDefIx].paramList := vParamList;
    end;

    setLength(aDefs, vDefIx + 1); // readjust for over-allocation in the event of rejected lines
  finally
    vLines.free;
  end;
end;

function test(const aString: string; const aBoolean: boolean): boolean;
begin
  writeln(aString + ' from mmpAction');
end;

procedure testReadDefs(const aFilePath: string);
var
  vDefs: TDefs;
begin
  readDefs(vDefs, aFilePath);

  for var i := 0 to length(vDefs) - 1 do
  begin
    writeln('Suffix: ', vDefs[i].suffix);
    writeln('Params: ', vDefs[i].paramDefs);
    writeln('----------------------');
  end;
end;

begin
  try
    // testReadDefs('bazActionDefs.txt');

    copySection('', FILE_PATH_IN, NIL); // obtain vUnit only

    readDefs  (vDefs, FILE_PATH_IN);
    writeUnit (vDefs, FILE_PATH_IN);

    //var vResult := TAction<boolean>.pick(TRUE, test).perform('hello', TRUE);

//    var vTestParts := 'LoadsASpaces:  boolean  string           '.split([' ']);
//    var vTestParts := 'StringInteger: string integer'.split([':']);
//    var vTestParts := 'Boolean: boolean'.split([':'], TStringSplitOptions.ExcludeEmpty);
//    var vTestParts := ' boolean'.split([' '], TStringSplitOptions.ExcludeEmpty);
//    var vTestParts := 'NoParam:'.split([':'], TStringSplitOptions.ExcludeEmpty);
//    var vTestParts := 'NoParam'.split([':'], TStringSplitOptions.ExcludeEmpty);
//    writeLn(intToStr(length(vTestParts)));
//    writeLn(vTestParts[0]);
//    writeLn('>' + vTestParts[1] + '<');
  except
    on E: Exception do
      Writeln(E.ClassName, ': ', E.Message);
  end;
end.
